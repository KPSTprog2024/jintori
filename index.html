<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>陣取りゲーム</title>
  <!-- iPhoneやiPadでの表示を最適化 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">

  <style>
    /* 全体のリセット＆画面全体を使う指定 */
    html, body {
      margin: 0; 
      padding: 0; 
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      background-color: #f0f0f0;
      font-family: sans-serif;
      /* iPhoneでの“下に隙間”や“上に余白”防止のためoverflowをhiddenに */
      overflow: hidden;
    }

    /* メインコンテナ: 画面全体を覆う */
    #mainContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    /* ゲームコンテナ: 同じく画面全体 */
    #gameContainer {
      position: relative;
      width: 100%;
      height: 100%;
      /* ボタンが画面範囲外にならないよう、デフォルトではoverflow: visible; でもOK */
      overflow: visible;
    }

    /* キャンバス: アスペクト比(4:3)を維持しながら
       画面内に常にフィットするように object-fit: contain を使う。
       pointer-events: none; は不要。Canvasへのタップを取る必要があるため。 */
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      background-color: #fff;
      border: 1px solid #ccc;
      object-fit: contain; /* 画面サイズに収まるよう自動調整(縦持ち/横持ち両方) */
    }

    /* オーバーレイ (スタート画面・ゲームオーバー等) は画面全体を覆う */
    .overlay {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: none;
      /* 縦スクロール要らないように hidden */
      overflow: hidden;
    }

    .content {
      position: relative;
      /* 中央に配置するためにflexboxを使うなどの方法もあり */
      width: 80%;
      max-width: 600px; 
      margin: 5% auto 0; 
      text-align: center;
      color: #fff;
    }

    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 1.0rem;
      cursor: pointer;
    }

    /* Give Up ボタン */
    #giveUpButton {
      position: absolute;
      bottom: 5px;
      left: 5px;
      z-index: 10;
      padding: 8px 12px;
      font-size: 1rem;
    }

    /* ステージ選択ボタン */
    #stageSelection {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    .stageButton {
      min-width: 90px;
      margin: 5px;
      flex: 0 1 auto;
    }
  </style>
</head>
<body>
  <div id="mainContainer">
    <div id="gameContainer">
      <!-- キャンバス: 内部解像度800x600 はゲーム内で固定 -->
      <canvas id="gameCanvas" width="800" height="600"></canvas>

      <!-- スタート画面 -->
      <div id="startScreen" class="overlay">
        <div class="content">
          <h2>陣取りゲームへようこそ！</h2>
          <p>ステージを選択してください：</p>
          <div id="stageSelection">
            <!-- ステージボタンを並べる(チュートリアルはステージ1表記) -->
            <button class="stageButton" data-stage="1">ステージ 1</button>
            <button class="stageButton" data-stage="2">ステージ 2</button>
            <button class="stageButton" data-stage="3">ステージ 3</button>
            <button class="stageButton" data-stage="4">ステージ 4</button>
            <button class="stageButton" data-stage="5">ステージ 5</button>
            <button class="stageButton" data-stage="6">ステージ 6</button>
            <button class="stageButton" data-stage="7">ステージ 7</button>
            <button class="stageButton" data-stage="8">ステージ 8</button>
            <button class="stageButton" data-stage="9">ステージ 9</button>
            <button class="stageButton" data-stage="10">ステージ 10</button>
          </div>
        </div>
      </div>

      <!-- ステージクリア画面 -->
      <div id="levelComplete" class="overlay">
        <div class="content">
          <h2>ステージクリア！</h2>
          <button id="retryLevelButton">もう一回同じレベル</button>
          <button id="nextLevelButton">次のレベル</button>
        </div>
      </div>

      <!-- ゲームオーバー画面 -->
      <div id="gameOver" class="overlay">
        <div class="content">
          <h2>ゲームオーバー</h2>
          <button id="restartButton">最初に戻る</button>
          <button id="retryButton">もう一回同じレベル</button>
        </div>
      </div>
    </div>

    <!-- Give Up ボタン -->
    <button id="giveUpButton">Give Up</button>
  </div>

  <script>
    /* =========================
       ========  ステージデータ  =======
       ========================= */
    const stages = [
      // index 0 → 「ステージ1: チュートリアル」
      {
        areas: [
          { id: 1, x: 200, y: 300, owner: 'player', virusCount: 10, growthRate: 1 },
          { id: 2, x: 400, y: 200, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 3, x: 400, y: 400, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 4, x: 600, y: 300, owner: 'neutral', virusCount: 5, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [2, 4],
          [1, 3],
          [3, 4],
        ],
      },
      // 以下、ステージ2〜10 (同内容は前回と変わらず)
      {
        areas: [
          { id: 1, x: 100, y: 300, owner: 'player', virusCount: 10, growthRate: 1 },
          { id: 2, x: 250, y: 150, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 3, x: 250, y: 450, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 4, x: 400, y: 300, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 5, x: 550, y: 150, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 6, x: 550, y: 450, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 7, x: 700, y: 300, owner: 'enemy', virusCount: 10, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
        ],
      },
      {
        areas: [
          { id: 1, x: 100, y: 100, owner: 'player', virusCount: 15, growthRate: 1 },
          { id: 2, x: 100, y: 500, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 3, x: 400, y: 100, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 4, x: 400, y: 300, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 5, x: 400, y: 500, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 6, x: 700, y: 100, owner: 'enemy', virusCount: 15, growthRate: 1 },
          { id: 7, x: 700, y: 500, owner: 'neutral', virusCount: 5, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 5],
          [3, 4],
          [4, 5],
          [4, 7],
          [5, 7],
          [3, 6],
          [6, 7],
        ],
      },
      {
        areas: [
          { id: 1, x: 400, y: 50, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 2, x: 250, y: 150, owner: 'player', virusCount: 20, growthRate: 1 },
          { id: 3, x: 550, y: 150, owner: 'enemy', virusCount: 20, growthRate: 1 },
          { id: 4, x: 400, y: 250, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 5, x: 250, y: 350, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 6, x: 550, y: 350, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 7, x: 400, y: 450, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 8, x: 400, y: 550, owner: 'neutral', virusCount: 5, growthRate: 2 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
          [7, 8],
        ],
      },
      {
        areas: [
          { id: 1, x: 150, y: 300, owner: 'player', virusCount: 20, growthRate: 1 },
          { id: 2, x: 300, y: 150, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 3, x: 300, y: 450, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 4, x: 450, y: 300, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 5, x: 600, y: 150, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 6, x: 600, y: 450, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 7, x: 750, y: 300, owner: 'enemy', virusCount: 25, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
        ],
      },
      {
        areas: [
          { id: 1, x: 400, y: 50, owner: 'player', virusCount: 20, growthRate: 1 },
          { id: 2, x: 200, y: 200, owner: 'enemy', virusCount: 10, growthRate: 2 },
          { id: 3, x: 600, y: 200, owner: 'neutral', virusCount: 20, growthRate: 2 },
          { id: 4, x: 400, y: 350, owner: 'neutral', virusCount: 20, growthRate: 1 },
          { id: 5, x: 200, y: 500, owner: 'enemy', virusCount: 25, growthRate: 1 },
          { id: 6, x: 600, y: 500, owner: 'player', virusCount: 10, growthRate: 2 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
        ],
      },
      {
        areas: [
          { id: 1, x: 100, y: 100, owner: 'player', virusCount: 35, growthRate: 2 },
          { id: 2, x: 700, y: 100, owner: 'enemy', virusCount: 40, growthRate: 1 },
          { id: 3, x: 400, y: 200, owner: 'neutral', virusCount: 25, growthRate: 2 },
          { id: 4, x: 250, y: 350, owner: 'neutral', virusCount: 25, growthRate: 1 },
          { id: 5, x: 550, y: 350, owner: 'neutral', virusCount: 25, growthRate: 2 },
          { id: 6, x: 100, y: 500, owner: 'neutral', virusCount: 25, growthRate: 2 },
          { id: 7, x: 700, y: 500, owner: 'enemy', virusCount: 20, growthRate: 1 },
        ],
        connections: [
          [1, 3],
          [2, 3],
          [3, 4],
          [3, 5],
          [4, 6],
          [5, 7],
        ],
      },
      {
        areas: [
          { id: 1, x: 400, y: 50, owner: 'player', virusCount: 40, growthRate: 1 },
          { id: 2, x: 250, y: 150, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 3, x: 550, y: 150, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 4, x: 250, y: 350, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 5, x: 550, y: 350, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 6, x: 250, y: 550, owner: 'enemy', virusCount: 25, growthRate: 1 },
          { id: 7, x: 550, y: 550, owner: 'enemy', virusCount: 25, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 5],
          [4, 6],
          [5, 7],
          [4, 5],
        ],
      },
      {
        areas: [
          { id: 1, x: 100, y: 300, owner: 'player', virusCount: 25, growthRate: 1 },
          { id: 2, x: 250, y: 150, owner: 'neutral', virusCount: 20, growthRate: 2 },
          { id: 3, x: 250, y: 450, owner: 'neutral', virusCount: 35, growthRate: 2 },
          { id: 4, x: 400, y: 300, owner: 'neutral', virusCount: 40, growthRate: 2 },
          { id: 5, x: 550, y: 150, owner: 'neutral', virusCount: 35, growthRate: 2 },
          { id: 6, x: 550, y: 450, owner: 'neutral', virusCount: 20, growthRate: 2 },
          { id: 7, x: 700, y: 300, owner: 'enemy', virusCount: 30, growthRate: 2 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
          [2, 5],
          [3, 6],
        ],
      },
      {
        areas: [
          { id: 1, x: 400, y: 50, owner: 'player', virusCount: 40, growthRate: 1 },
          { id: 2, x: 200, y: 200, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 3, x: 600, y: 200, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 4, x: 400, y: 350, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 5, x: 200, y: 500, owner: 'enemy', virusCount: 35, growthRate: 1 },
          { id: 6, x: 600, y: 500, owner: 'enemy', virusCount: 35, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [2, 5],
          [3, 6],
        ],
      },
    ];

    /* =========================
       ========  ゲーム本体  =======
       ========================= */

    // キャンバス・コンテキスト
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // オーバーレイ取得
    const startScreen = document.getElementById('startScreen');
    const levelCompleteOverlay = document.getElementById('levelComplete');
    const nextLevelButton = document.getElementById('nextLevelButton');
    const retryLevelButton = document.getElementById('retryLevelButton');
    const gameOverOverlay = document.getElementById('gameOver');
    const retryButton = document.getElementById('retryButton');
    const restartButton = document.getElementById('restartButton');

    // ステージ選択ボタン
    const stageButtons = document.querySelectorAll('.stageButton');

    // ゲーム状態
    let currentStage = 0;
    let areas = [];
    let connections = [];
    let selectedArea = null;
    let gameInterval;

    // 攻撃ブロック配列
    let attackBlocks = [];

    // エリアの半径
    const AREA_RADIUS = 50;

    // 各種カウンター
    let virusGrowthCounter = 0;
    let enemyActionCounter = 0;

    // 攻撃ブロック速度
    const ATTACK_BLOCK_SPEED = 2;

    // ウイルス数上限
    const MAX_VIRUS_COUNT = 40;

    // Give Up ボタン
    const giveUpButton = document.getElementById('giveUpButton');
    let giveUpState = 'giveUp'; // 'giveUp' or 'restart'


    // ======================
    //   初期化関数
    // ======================
    function initGame() {
      startScreen.style.display = 'block';
      giveUpButton.style.display = 'none';
      giveUpButton.textContent = 'Give Up';
      giveUpButton.style.backgroundColor = '';
      giveUpState = 'giveUp';
    }

    // ======================
    //   ステージ選択
    // ======================
    stageButtons.forEach(button => {
      button.addEventListener('click', () => {
        const selectedStage = parseInt(button.getAttribute('data-stage'), 10);
        startScreen.style.display = 'none';
        startStage(selectedStage);
      });
    });

    // ======================
    //   Give Up ボタン
    // ======================
    giveUpButton.addEventListener('click', () => {
      if (giveUpState === 'giveUp') {
        giveUpButton.textContent = 'Restart';
        giveUpButton.style.backgroundColor = '#f00';
        giveUpState = 'restart';
      } else {
        giveUpButton.textContent = 'Give Up';
        giveUpButton.style.backgroundColor = '';
        giveUpState = 'giveUp';
        startStage(currentStage);
      }
    });

    // ======================
    //   ステージ開始
    // ======================
    function startStage(stageNumber) {
      currentStage = stageNumber;
      attackBlocks = [];
      setupStage(stageNumber);
      drawAreas();

      if (gameInterval) clearInterval(gameInterval);
      virusGrowthCounter = 0;
      enemyActionCounter = 0;
      // 50msごとにループ
      gameInterval = setInterval(gameLoop, 50);

      // Give Upボタン表示
      giveUpButton.style.display = 'block';
      giveUpButton.textContent = 'Give Up';
      giveUpButton.style.backgroundColor = '';
      giveUpState = 'giveUp';
    }

    // ======================
    //   ステージ設定
    // ======================
    function setupStage(stageNumber) {
      const index = stageNumber - 1;
      if (index < stages.length && index >= 0) {
        const stageData = stages[index];
        areas = stageData.areas.map(a => ({ ...a }));
        connections = stageData.connections.map(c => [...c]);
      } else {
        // もしステージ11以降を作るならここでランダム生成する等
        areas = [];
        connections = [];
      }
      selectedArea = null;
    }

    // ======================
    //   画面描画
    // ======================
    function drawAreas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ステージ番号表示
      ctx.fillStyle = 'black';
      ctx.font = '24px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(`ステージ ${currentStage}`, 10, 10);

      // 接続線
      connections.forEach(conn => {
        const area1 = areas.find(a => a.id === conn[0]);
        const area2 = areas.find(a => a.id === conn[1]);
        if (!area1 || !area2) return;

        const angle = Math.atan2(area2.y - area1.y, area2.x - area1.x);
        const x1 = area1.x + AREA_RADIUS * Math.cos(angle);
        const y1 = area1.y + AREA_RADIUS * Math.sin(angle);
        const x2 = area2.x - AREA_RADIUS * Math.cos(angle);
        const y2 = area2.y - AREA_RADIUS * Math.sin(angle);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = '#ccc';
        ctx.stroke();
      });

      // 攻撃ブロック描画
      attackBlocks.forEach(block => {
        ctx.beginPath();
        ctx.arc(block.x, block.y, 12, 0, Math.PI * 2);
        ctx.fillStyle = block.owner === 'player' ? 'red' : 'orange';
        ctx.fill();

        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(block.virusCount, block.x, block.y);
      });

      // エリア描画
      areas.forEach(area => {
        ctx.beginPath();
        ctx.arc(area.x, area.y, AREA_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle =
          area.owner === 'player' ? 'red' :
          area.owner === 'enemy' ? 'orange' : 'white';
        ctx.fill();

        let lineWidth = 1;
        let strokeStyle = 'black';

        if (selectedArea === area) {
          lineWidth = 5;
          strokeStyle = 'darkred';
        } else if (selectedArea && isNeighbor(selectedArea, area)) {
          lineWidth = 5;
          strokeStyle = 'darkblue';
        }

        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = strokeStyle;
        ctx.stroke();

        // ウイルス数・増殖率
        ctx.fillStyle = 'black';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(area.virusCount, area.x, area.y + 5);
        ctx.fillText(`×${area.growthRate}`, area.x, area.y + 30);
      });
    }

    // ======================
    //   隣接判定
    // ======================
    function isNeighbor(fromArea, toArea) {
      return connections.some(conn =>
        (conn[0] === fromArea.id && conn[1] === toArea.id) ||
        (conn[1] === fromArea.id && conn[0] === toArea.id)
      );
    }

    // ======================
    //   クリック処理
    // ======================
    canvas.addEventListener('click', function(event) {
      const rect = canvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;

      const clickedArea = areas.find(area => {
        const dx = area.x - clickX;
        const dy = area.y - clickY;
        return Math.sqrt(dx * dx + dy * dy) < AREA_RADIUS;
      });

      if (clickedArea) {
        if (!selectedArea) {
          // 自エリア選択
          if (clickedArea.owner === 'player' && clickedArea.virusCount > 0) {
            selectedArea = clickedArea;
            drawAreas();
          }
        } else {
          // 移動先
          if (isNeighbor(selectedArea, clickedArea)) {
            moveVirus(selectedArea.id, clickedArea.id);
            selectedArea = null;
            drawAreas();
          } else {
            selectedArea = null;
            drawAreas();
          }
        }
      } else {
        selectedArea = null;
        drawAreas();
      }
    });

    // ======================
    //   ウイルス移動 → 攻撃ブロック
    // ======================
    function moveVirus(fromId, toId) {
      const fromArea = areas.find(a => a.id === fromId);
      const toArea = areas.find(a => a.id === toId);
      if (!fromArea || !toArea) return;
      if (fromArea.owner !== 'player') return;

      const playerBlocksOnRoute = attackBlocks.filter(
        b => b.owner === 'player' && b.fromArea.id === fromArea.id && b.toArea.id === toArea.id
      );
      if (playerBlocksOnRoute.length >= 3) return;

      const movingVirus = fromArea.virusCount;
      if (movingVirus <= 0) return;
      fromArea.virusCount -= movingVirus;

      createAttackBlock(fromArea, toArea, movingVirus, 'player');
    }

    // ======================
    //   攻撃ブロック作成
    // ======================
    function createAttackBlock(fromArea, toArea, virusCount, owner) {
      const dx = toArea.x - fromArea.x;
      const dy = toArea.y - fromArea.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const unitX = dx / distance;
      const unitY = dy / distance;

      const startX = fromArea.x + AREA_RADIUS * unitX;
      const startY = fromArea.y + AREA_RADIUS * unitY;
      const endX = toArea.x - AREA_RADIUS * unitX;
      const endY = toArea.y - AREA_RADIUS * unitY;
      const totalDistance = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);

      attackBlocks.push({
        owner,
        virusCount,
        fromArea,
        toArea,
        x: startX,
        y: startY,
        dx: unitX,
        dy: unitY,
        totalDistance,
        distanceTraveled: 0,
        speed: ATTACK_BLOCK_SPEED,
      });
    }

    // ======================
    //   攻撃ブロック更新
    // ======================
    function updateAttackBlocks() {
      for (let i = 0; i < attackBlocks.length; i++) {
        const block = attackBlocks[i];
        block.distanceTraveled += block.speed;
        block.x += block.dx * block.speed;
        block.y += block.dy * block.speed;

        // 衝突判定(攻撃ブロック同士)
        for (let j = i + 1; j < attackBlocks.length; j++) {
          const otherBlock = attackBlocks[j];
          const samePath =
            (block.fromArea.id === otherBlock.fromArea.id && block.toArea.id === otherBlock.toArea.id) ||
            (block.fromArea.id === otherBlock.toArea.id && block.toArea.id === otherBlock.fromArea.id);
          if (!samePath) continue;

          if (block.owner !== otherBlock.owner) {
            const dx = block.x - otherBlock.x;
            const dy = block.y - otherBlock.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < 24) {
              if (block.virusCount > otherBlock.virusCount) {
                block.virusCount -= otherBlock.virusCount;
                attackBlocks.splice(j, 1);
                j--;
              } else if (block.virusCount < otherBlock.virusCount) {
                otherBlock.virusCount -= block.virusCount;
                attackBlocks.splice(i, 1);
                i--;
                break;
              } else {
                attackBlocks.splice(j, 1);
                attackBlocks.splice(i, 1);
                i--;
                break;
              }
            }
          }
        }

        // ターゲット到達
        const targetDistance = Math.sqrt((block.x - block.toArea.x) ** 2 + (block.y - block.toArea.y) ** 2);
        if (targetDistance <= AREA_RADIUS || block.distanceTraveled >= block.totalDistance) {
          const toArea = block.toArea;
          const movingVirus = block.virusCount;

          if (toArea.owner === block.owner) {
            toArea.virusCount += movingVirus;
            if (toArea.virusCount > MAX_VIRUS_COUNT) {
              toArea.virusCount = MAX_VIRUS_COUNT;
            }
          } else if (toArea.owner === 'neutral') {
            if (movingVirus > toArea.virusCount) {
              toArea.owner = block.owner;
              toArea.virusCount = movingVirus - toArea.virusCount;
            } else if (movingVirus === toArea.virusCount) {
              toArea.owner = 'neutral';
              toArea.virusCount = 0;
            } else {
              toArea.virusCount -= movingVirus;
            }
          } else {
            if (movingVirus > toArea.virusCount) {
              toArea.owner = block.owner;
              toArea.virusCount = movingVirus - toArea.virusCount;
            } else if (movingVirus === toArea.virusCount) {
              toArea.owner = 'neutral';
              toArea.virusCount = 0;
            } else {
              toArea.virusCount -= movingVirus;
            }
          }
          if (toArea.virusCount > MAX_VIRUS_COUNT) {
            toArea.virusCount = MAX_VIRUS_COUNT;
          }

          // ブロック削除
          attackBlocks.splice(i, 1);
          i--;
        }
      }
    }

    // ======================
    //   敵の行動
    // ======================
    function enemyAction() {
      const enemyAreas = areas.filter(a => a.owner === 'enemy' && a.virusCount > 0);
      enemyAreas.forEach(area => {
        const neighboringAreas = connections
          .filter(conn => conn.includes(area.id))
          .map(conn => (conn[0] === area.id ? conn[1] : conn[0]))
          .map(id => areas.find(a => a.id === id));

        if (!neighboringAreas.length) return;

        let targetArea;
        if (currentStage <= 5) {
          // ランダム攻撃
          targetArea = neighboringAreas[Math.floor(Math.random() * neighboringAreas.length)];
        } else {
          // プレイヤーのウイルス数が少ないエリア優先
          const playerAreas = neighboringAreas.filter(a => a.owner === 'player');
          if (playerAreas.length > 0) {
            targetArea = playerAreas.reduce(
              (minArea, a) => (a.virusCount < minArea.virusCount ? a : minArea),
              playerAreas[0]
            );
          } else {
            targetArea = neighboringAreas[Math.floor(Math.random() * neighboringAreas.length)];
          }
        }

        if (targetArea && area.virusCount > 0) {
          const enemyBlocksOnRoute = attackBlocks.filter(
            b => b.owner === 'enemy' && b.fromArea.id === area.id && b.toArea.id === targetArea.id
          );
          if (enemyBlocksOnRoute.length >= 3) return;

          const movingVirus = area.virusCount;
          area.virusCount -= movingVirus;
          createAttackBlock(area, targetArea, movingVirus, 'enemy');
        }
      });
    }

    // ======================
    //   勝敗判定
    // ======================
    function checkGameStatus() {
      const playerOwned = areas.filter(a => a.owner === 'player').length;
      const totalAreas = areas.length;

      if (playerOwned === 0) {
        clearInterval(gameInterval);
        attackBlocks = [];
        gameOverOverlay.style.display = 'block';
      } else if (playerOwned === totalAreas) {
        clearInterval(gameInterval);
        attackBlocks = [];
        levelCompleteOverlay.style.display = 'block';
      }
    }

    // ======================
    //   ゲームループ
    // ======================
    function gameLoop() {
      virusGrowthCounter += 50;
      enemyActionCounter += 50;

      if (virusGrowthCounter >= 1000) {
        increaseVirusCounts();
        virusGrowthCounter = 0;
      }
      if (enemyActionCounter >= 1000 && currentStage !== 0) {
        enemyAction();
        enemyActionCounter = 0;
      }

      updateAttackBlocks();
      checkGameStatus();
      drawAreas();
    }

    // ======================
    //   ウイルス増殖（上限あり）
    // ======================
    function increaseVirusCounts() {
      areas.forEach(a => {
        if (a.owner !== 'neutral') {
          a.virusCount += a.growthRate;
          if (a.virusCount > MAX_VIRUS_COUNT) {
            a.virusCount = MAX_VIRUS_COUNT;
          }
        }
      });
    }

    // ======================
    //   イベント設定
    // ======================
    retryLevelButton.addEventListener('click', () => {
      levelCompleteOverlay.style.display = 'none';
      startStage(currentStage);
    });
    nextLevelButton.addEventListener('click', () => {
      levelCompleteOverlay.style.display = 'none';
      startStage(currentStage + 1);
    });

    restartButton.addEventListener('click', () => {
      gameOverOverlay.style.display = 'none';
      initGame();
    });
    retryButton.addEventListener('click', () => {
      gameOverOverlay.style.display = 'none';
      startStage(currentStage);
    });

    // ゲーム開始
    initGame();
  </script>
</body>
</html>
