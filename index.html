<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>陣取りゲーム</title>
  <!-- iPhoneやiPadでの表示を最適化 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">

  <style>
    /* 全体のリセット＆画面全体を使う指定 */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      background-color: #f0f0f0;
      font-family: sans-serif;
      /* overflow: hidden;  /* スクロールを無効化しない */
    }

    /* メインコンテナ: 画面全体を覆う */
    #mainContainer {
      position: fixed; /* fixedに変更してスクロールに影響されないように */
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden; /* 内部でスクロールを無効化 */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* ゲームコンテナ: 同じく画面全体 */
    #gameContainer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: visible;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* キャンバス: アスペクト比(16:9)を維持しながら画面内に常にフィットする。
       width="960" height="540" で内部解像度を16:9に固定。
       object-fit: contain で実際の画面領域内に収める。 */
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      background-color: #fff;
      border: 1px solid #ccc;
      object-fit: contain;
      /* 余白の位置を中央に */
      object-position: 50% 50%;
    }

    /* オーバーレイ (スタート/クリア/ゲームオーバー画面) */
    .overlay {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: none;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .content {
      position: relative;
      width: 80%;
      max-width: 600px; 
      margin: 0 auto; 
      text-align: center;
      color: #fff;
    }

    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 1.0rem;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background-color: #007BFF;
      color: #fff;
    }

    button:hover {
      background-color: #0056b3;
    }

    /* Give Up ボタン */
    #giveUpButton {
      position: absolute;
      bottom: 5px;
      left: 5px;
      z-index: 10;
      padding: 8px 12px;
      font-size: 1rem;
      border: none;
      border-radius: 5px;
      background-color: #dc3545;
      color: #fff;
      cursor: pointer;
    }

    #giveUpButton.restart {
      background-color: #28a745;
    }

    /* ステージ選択ボタン */
    #stageSelection {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    .stageButton {
      min-width: 90px;
      margin: 5px;
      flex: 0 1 auto;
      border: none;
      border-radius: 5px;
      background-color: #17a2b8;
      color: #fff;
      cursor: pointer;
    }

    .stageButton:hover {
      background-color: #117a8b;
    }
  </style>
</head>
<body>
  <div id="mainContainer">
    <div id="gameContainer">
      <!-- キャンバス: 内部解像度960×540(16:9) -->
      <canvas id="gameCanvas" width="960" height="540"></canvas>

      <!-- スタート画面 -->
      <div id="startScreen" class="overlay">
        <div class="content">
          <h2>陣取りゲームへようこそ！</h2>
          <p>ステージを選択してください：</p>
          <div id="stageSelection">
            <!-- ステージボタンを並べる(チュートリアルはステージ1表記) -->
            <button class="stageButton" data-stage="1">ステージ 1</button>
            <button class="stageButton" data-stage="2">ステージ 2</button>
            <button class="stageButton" data-stage="3">ステージ 3</button>
            <button class="stageButton" data-stage="4">ステージ 4</button>
            <button class="stageButton" data-stage="5">ステージ 5</button>
            <button class="stageButton" data-stage="6">ステージ 6</button>
            <button class="stageButton" data-stage="7">ステージ 7</button>
            <button class="stageButton" data-stage="8">ステージ 8</button>
            <button class="stageButton" data-stage="9">ステージ 9</button>
            <button class="stageButton" data-stage="10">ステージ 10</button>
          </div>
        </div>
      </div>

      <!-- ステージクリア画面 -->
      <div id="levelComplete" class="overlay">
        <div class="content">
          <h2>ステージクリア！</h2>
          <button id="retryLevelButton">もう一回同じレベル</button>
          <button id="nextLevelButton">次のレベル</button>
        </div>
      </div>

      <!-- ゲームオーバー画面 -->
      <div id="gameOver" class="overlay">
        <div class="content">
          <h2>ゲームオーバー</h2>
          <button id="restartButton">最初に戻る</button>
          <button id="retryButton">もう一回同じレベル</button>
        </div>
      </div>
    </div>

    <!-- Give Up ボタン -->
    <button id="giveUpButton">Give Up</button>
  </div>

  <script>
    /* =========================
       ========  ステージデータ  =======
       ========================= */
    const stages = [
      // index 0 → 「ステージ1: チュートリアル」
      {
        areas: [
          { id: 1, x: 200, y: 270, owner: 'player', virusCount: 10, growthRate: 1 },
          { id: 2, x: 480, y: 180, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 3, x: 480, y: 360, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 4, x: 760, y: 270, owner: 'neutral', virusCount: 5, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [2, 4],
          [1, 3],
          [3, 4],
        ],
      },
      // 以下、ステージ2〜10 (内部座標も16:9に合わせて微調整推奨)
      {
        areas: [
          { id: 1, x: 100, y: 270, owner: 'player', virusCount: 10, growthRate: 1 },
          { id: 2, x: 240, y: 130, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 3, x: 240, y: 410, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 4, x: 400, y: 270, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 5, x: 560, y: 130, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 6, x: 560, y: 410, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 7, x: 720, y: 270, owner: 'enemy', virusCount: 10, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
        ],
      },
      {
        areas: [
          { id: 1, x: 100, y: 100, owner: 'player', virusCount: 15, growthRate: 1 },
          { id: 2, x: 100, y: 440, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 3, x: 400, y: 100, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 4, x: 400, y: 270, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 5, x: 400, y: 440, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 6, x: 700, y: 100, owner: 'enemy', virusCount: 15, growthRate: 1 },
          { id: 7, x: 700, y: 440, owner: 'neutral', virusCount: 5, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 5],
          [3, 4],
          [4, 5],
          [4, 7],
          [5, 7],
          [3, 6],
          [6, 7],
        ],
      },
      {
        areas: [
          { id: 1, x: 480, y:  40, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 2, x: 300, y: 140, owner: 'player', virusCount: 20, growthRate: 1 },
          { id: 3, x: 660, y: 140, owner: 'enemy', virusCount: 20, growthRate: 1 },
          { id: 4, x: 480, y: 240, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 5, x: 300, y: 340, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 6, x: 660, y: 340, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 7, x: 480, y: 440, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 8, x: 480, y: 500, owner: 'neutral', virusCount: 5, growthRate: 2 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
          [7, 8],
        ],
      },
      {
        areas: [
          { id: 1, x: 120, y: 270, owner: 'player', virusCount: 20, growthRate: 1 },
          { id: 2, x: 280, y: 130, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 3, x: 280, y: 410, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 4, x: 440, y: 270, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 5, x: 600, y: 130, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 6, x: 600, y: 410, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 7, x: 760, y: 270, owner: 'enemy', virusCount: 25, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
        ],
      },
      {
        areas: [
          { id: 1, x: 480, y:  40, owner: 'player', virusCount: 20, growthRate: 1 },
          { id: 2, x: 240, y: 180, owner: 'enemy', virusCount: 10, growthRate: 2 },
          { id: 3, x: 720, y: 180, owner: 'neutral', virusCount: 20, growthRate: 2 },
          { id: 4, x: 480, y: 320, owner: 'neutral', virusCount: 20, growthRate: 1 },
          { id: 5, x: 240, y: 460, owner: 'enemy', virusCount: 25, growthRate: 1 },
          { id: 6, x: 720, y: 460, owner: 'player', virusCount: 10, growthRate: 2 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
        ],
      },
      {
        areas: [
          { id: 1, x: 100, y: 100, owner: 'player', virusCount: 35, growthRate: 2 },
          { id: 2, x: 860, y: 100, owner: 'enemy', virusCount: 40, growthRate: 1 },
          { id: 3, x: 480, y: 180, owner: 'neutral', virusCount: 25, growthRate: 2 },
          { id: 4, x: 300, y: 300, owner: 'neutral', virusCount: 25, growthRate: 1 },
          { id: 5, x: 660, y: 300, owner: 'neutral', virusCount: 25, growthRate: 2 },
          { id: 6, x: 100, y: 460, owner: 'neutral', virusCount: 25, growthRate: 2 },
          { id: 7, x: 860, y: 460, owner: 'enemy', virusCount: 20, growthRate: 1 },
        ],
        connections: [
          [1, 3],
          [2, 3],
          [3, 4],
          [3, 5],
          [4, 6],
          [5, 7],
        ],
      },
      {
        areas: [
          { id: 1, x: 480, y:  40, owner: 'player', virusCount: 40, growthRate: 1 },
          { id: 2, x: 300, y: 140, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 3, x: 660, y: 140, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 4, x: 300, y: 300, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 5, x: 660, y: 300, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 6, x: 300, y: 460, owner: 'enemy', virusCount: 25, growthRate: 1 },
          { id: 7, x: 660, y: 460, owner: 'enemy', virusCount: 25, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 5],
          [4, 6],
          [5, 7],
          [4, 5],
        ],
      },
      {
        areas: [
          { id: 1, x: 100, y: 270, owner: 'player', virusCount: 25, growthRate: 1 },
          { id: 2, x: 240, y: 130, owner: 'neutral', virusCount: 20, growthRate: 2 },
          { id: 3, x: 240, y: 410, owner: 'neutral', virusCount: 35, growthRate: 2 },
          { id: 4, x: 400, y: 270, owner: 'neutral', virusCount: 40, growthRate: 2 },
          { id: 5, x: 560, y: 130, owner: 'neutral', virusCount: 35, growthRate: 2 },
          { id: 6, x: 560, y: 410, owner: 'neutral', virusCount: 20, growthRate: 2 },
          { id: 7, x: 720, y: 270, owner: 'enemy', virusCount: 30, growthRate: 2 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
          [2, 5],
          [3, 6],
        ],
      },
      {
        areas: [
          { id: 1, x: 480, y:  40, owner: 'player', virusCount: 40, growthRate: 1 },
          { id: 2, x: 200, y: 180, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 3, x: 760, y: 180, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 4, x: 480, y: 320, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 5, x: 200, y: 460, owner: 'enemy', virusCount: 35, growthRate: 1 },
          { id: 6, x: 760, y: 460, owner: 'enemy', virusCount: 35, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [2, 5],
          [3, 6],
        ],
      },
    ];

    /* =========================
       ========  ゲーム本体  =======
       ========================= */

    // キャンバス・コンテキスト
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // オーバーレイ取得
    const startScreen = document.getElementById('startScreen');
    const levelCompleteOverlay = document.getElementById('levelComplete');
    const nextLevelButton = document.getElementById('nextLevelButton');
    const retryLevelButton = document.getElementById('retryLevelButton');
    const gameOverOverlay = document.getElementById('gameOver');
    const retryButton = document.getElementById('retryButton');
    const restartButton = document.getElementById('restartButton');

    // ステージ選択ボタン
    const stageButtons = document.querySelectorAll('.stageButton');

    // ゲーム状態
    let currentStage = 0;
    let areas = [];
    let connections = [];
    let selectedArea = null;
    let gameInterval;

    // 攻撃ブロック配列
    let attackBlocks = [];

    // エリアの半径（動的に設定）
    let AREA_RADIUS = 50;

    // 各種カウンター
    let virusGrowthCounter = 0;
    let enemyActionCounter = 0;

    // 攻撃ブロック速度
    const ATTACK_BLOCK_SPEED = 2;

    // ウイルス数上限
    const MAX_VIRUS_COUNT = 40;

    // Give Up ボタン
    const giveUpButton = document.getElementById('giveUpButton');
    let giveUpState = 'giveUp'; // 'giveUp' or 'restart'

    // ======================
    //   初期化関数
    // ======================
    function initGame() {
      startScreen.style.display = 'flex';
      levelCompleteOverlay.style.display = 'none';
      gameOverOverlay.style.display = 'none';
      giveUpButton.style.display = 'none';
      giveUpButton.textContent = 'Give Up';
      giveUpButton.classList.remove('restart');
      giveUpButton.style.backgroundColor = '';
      giveUpState = 'giveUp';
      selectedArea = null;
    }

    // ======================
    //   スケールと半径の調整
    // ======================
    function adjustCanvasAndRadius() {
      const rect = canvas.getBoundingClientRect();
      const scale = Math.min(rect.width / canvas.width, rect.height / canvas.height);
      AREA_RADIUS = 50 * scale; // 基本半径50をスケールに応じて調整
    }

    // ======================
    //   ステージ選択
    // ======================
    stageButtons.forEach(button => {
      // タッチイベント
      button.addEventListener('touchend', (e) => {
        e.preventDefault(); // スマホでのダブルタップズームなど防止
        const selectedStage = parseInt(button.getAttribute('data-stage'), 10);
        startScreen.style.display = 'none';
        startStage(selectedStage);
      }, { passive: false });

      // クリックイベント
      button.addEventListener('click', (e) => {
        e.preventDefault();
        const selectedStage = parseInt(button.getAttribute('data-stage'), 10);
        startScreen.style.display = 'none';
        startStage(selectedStage);
      });
    });

    // ======================
    //   Give Up ボタン
    // ======================
    function handleGiveUp(e) {
      e.preventDefault();
      if (giveUpState === 'giveUp') {
        giveUpButton.textContent = 'Restart';
        giveUpButton.classList.add('restart');
        giveUpState = 'restart';
      } else {
        giveUpButton.textContent = 'Give Up';
        giveUpButton.classList.remove('restart');
        giveUpState = 'giveUp';
        startStage(currentStage);
      }
    }

    giveUpButton.addEventListener('touchend', handleGiveUp, { passive: false });
    giveUpButton.addEventListener('click', handleGiveUp);

    // ======================
    //   ステージ開始
    // ======================
    function startStage(stageNumber) {
      currentStage = stageNumber;
      attackBlocks = [];
      setupStage(stageNumber);
      adjustCanvasAndRadius();
      drawAreas();

      if (gameInterval) clearInterval(gameInterval);
      virusGrowthCounter = 0;
      enemyActionCounter = 0;
      // 50msごとにループ (20fps)
      gameInterval = setInterval(gameLoop, 50);

      // Give Upボタン表示
      giveUpButton.style.display = 'block';
      giveUpButton.textContent = 'Give Up';
      giveUpButton.classList.remove('restart');
      giveUpButton.style.backgroundColor = '#dc3545';
      giveUpState = 'giveUp';
    }

    // ======================
    //   ステージ設定
    // ======================
    function setupStage(stageNumber) {
      const index = stageNumber - 1;
      if (index < stages.length && index >= 0) {
        const stageData = stages[index];
        areas = stageData.areas.map(a => ({ ...a }));
        connections = stageData.connections.map(c => [...c]);
      } else {
        // もしステージ11以降を作るなら、ここでランダム生成等の処理を入れる
        areas = [];
        connections = [];
      }
      selectedArea = null;
    }

    // ======================
    //   画面描画
    // ======================
    function drawAreas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ステージ番号表示
      ctx.fillStyle = 'black';
      ctx.font = '24px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(`ステージ ${currentStage}`, 10, 10);

      // 接続線
      connections.forEach(conn => {
        const area1 = areas.find(a => a.id === conn[0]);
        const area2 = areas.find(a => a.id === conn[1]);
        if (!area1 || !area2) return;

        const angle = Math.atan2(area2.y - area1.y, area2.x - area1.x);
        const x1 = area1.x + AREA_RADIUS * Math.cos(angle);
        const y1 = area1.y + AREA_RADIUS * Math.sin(angle);
        const x2 = area2.x - AREA_RADIUS * Math.cos(angle);
        const y2 = area2.y - AREA_RADIUS * Math.sin(angle);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      // 攻撃ブロック描画
      attackBlocks.forEach(block => {
        ctx.beginPath();
        ctx.arc(block.x, block.y, AREA_RADIUS * 0.24, 0, Math.PI * 2); // 半径をスケールに応じて調整
        ctx.fillStyle = block.owner === 'player' ? 'red' : 'orange';
        ctx.fill();

        ctx.fillStyle = 'white';
        ctx.font = `${12 * (AREA_RADIUS / 50)}px Arial`; // フォントサイズもスケールに応じて調整
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(block.virusCount, block.x, block.y);
      });

      // エリア描画
      areas.forEach(area => {
        ctx.beginPath();
        ctx.arc(area.x, area.y, AREA_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle =
          area.owner === 'player' ? 'red' :
          area.owner === 'enemy' ? 'orange' : 'white';
        ctx.fill();

        let lineWidth = 1;
        let strokeStyle = 'black';

        if (selectedArea === area) {
          lineWidth = 5;
          strokeStyle = 'darkred';
        } else if (selectedArea && isNeighbor(selectedArea, area)) {
          lineWidth = 5;
          strokeStyle = 'darkblue';
        }

        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = strokeStyle;
        ctx.stroke();

        // ウイルス数・増殖率
        ctx.fillStyle = 'black';
        ctx.font = `${18 * (AREA_RADIUS / 50)}px Arial`; // フォントサイズもスケールに応じて調整
        ctx.textAlign = 'center';
        ctx.fillText(area.virusCount, area.x, area.y + 5 * (AREA_RADIUS / 50));
        ctx.fillText(`×${area.growthRate}`, area.x, area.y + 30 * (AREA_RADIUS / 50));
      });
    }

    // ======================
    //   隣接判定
    // ======================
    function isNeighbor(fromArea, toArea) {
      return connections.some(conn =>
        (conn[0] === fromArea.id && conn[1] === toArea.id) ||
        (conn[1] === fromArea.id && conn[0] === toArea.id)
      );
    }

    // ======================
    //   タッチ位置をキャンバス座標に変換
    // ======================
    function getCanvasCoordinates(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scale = Math.min(rect.width / canvas.width, rect.height / canvas.height);
      const xOffset = (rect.width - canvas.width * scale) / 2;
      const yOffset = (rect.height - canvas.height * scale) / 2;
      const x = (clientX - rect.left - xOffset) / scale;
      const y = (clientY - rect.top - yOffset) / scale;
      return { x, y };
    }

    // ======================
    //   タッチ処理
    // ======================
    function handleCanvasInteraction(x, y) {
      const clickedArea = areas.find(area => {
        const dx = area.x - x;
        const dy = area.y - y;
        return Math.sqrt(dx * dx + dy * dy) < AREA_RADIUS;
      });

      if (clickedArea) {
        if (!selectedArea) {
          // 自エリア選択
          if (clickedArea.owner === 'player' && clickedArea.virusCount > 0) {
            selectedArea = clickedArea;
            drawAreas();
          }
        } else {
          // 移動先
          if (isNeighbor(selectedArea, clickedArea)) {
            moveVirus(selectedArea.id, clickedArea.id);
            selectedArea = null;
            drawAreas();
          } else {
            selectedArea = null;
            drawAreas();
          }
        }
      } else {
        selectedArea = null;
        drawAreas();
      }
    }

    canvas.addEventListener('touchstart', function(e) {
      // タッチ時にスクロールしないように
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', function(e) {
      e.preventDefault();
      // シングルタッチ想定
      if (e.changedTouches.length === 0) return;
      const touch = e.changedTouches[0];

      const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
      handleCanvasInteraction(coords.x, coords.y);
    }, { passive: false });

    // クリックイベントの追加
    canvas.addEventListener('click', function(e) {
      const coords = getCanvasCoordinates(e.clientX, e.clientY);
      handleCanvasInteraction(coords.x, coords.y);
    });

    // ======================
    //   ウイルス移動 → 攻撃ブロック
    // ======================
    function moveVirus(fromId, toId) {
      const fromArea = areas.find(a => a.id === fromId);
      const toArea = areas.find(a => a.id === toId);
      if (!fromArea || !toArea) return;
      if (fromArea.owner !== 'player') return;

      const playerBlocksOnRoute = attackBlocks.filter(
        b => b.owner === 'player' && b.fromArea.id === fromArea.id && b.toArea.id === toArea.id
      );
      if (playerBlocksOnRoute.length >= 3) return;

      const movingVirus = fromArea.virusCount; // 全て移動
      if (movingVirus <= 0) return;
      fromArea.virusCount -= movingVirus;

      createAttackBlock(fromArea, toArea, movingVirus, 'player');
    }

    // ======================
    //   攻撃ブロック作成
    // ======================
    function createAttackBlock(fromArea, toArea, virusCount, owner) {
      const dx = toArea.x - fromArea.x;
      const dy = toArea.y - fromArea.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const unitX = dx / distance;
      const unitY = dy / distance;

      const startX = fromArea.x + AREA_RADIUS * unitX;
      const startY = fromArea.y + AREA_RADIUS * unitY;
      const endX = toArea.x - AREA_RADIUS * unitX;
      const endY = toArea.y - AREA_RADIUS * unitY;
      const totalDistance = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);

      attackBlocks.push({
        owner,
        virusCount,
        fromArea,
        toArea,
        x: startX,
        y: startY,
        dx: unitX,
        dy: unitY,
        totalDistance,
        distanceTraveled: 0,
        speed: ATTACK_BLOCK_SPEED,
      });
    }

    // ======================
    //   攻撃ブロック更新
    // ======================
    function updateAttackBlocks() {
      for (let i = 0; i < attackBlocks.length; i++) {
        const block = attackBlocks[i];
        block.distanceTraveled += block.speed;
        block.x += block.dx * block.speed;
        block.y += block.dy * block.speed;

        // 衝突判定(攻撃ブロック同士)
        for (let j = i + 1; j < attackBlocks.length; j++) {
          const otherBlock = attackBlocks[j];
          const samePath =
            (block.fromArea.id === otherBlock.fromArea.id && block.toArea.id === otherBlock.toArea.id) ||
            (block.fromArea.id === otherBlock.toArea.id && block.toArea.id === otherBlock.fromArea.id);
          if (!samePath) continue;

          if (block.owner !== otherBlock.owner) {
            const dx = block.x - otherBlock.x;
            const dy = block.y - otherBlock.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < 24) {
              // ウイルス数の差し引き
              if (block.virusCount > otherBlock.virusCount) {
                block.virusCount -= otherBlock.virusCount;
                attackBlocks.splice(j, 1);
                j--;
              } else if (block.virusCount < otherBlock.virusCount) {
                otherBlock.virusCount -= block.virusCount;
                attackBlocks.splice(i, 1);
                i--;
                break;
              } else {
                attackBlocks.splice(j, 1);
                attackBlocks.splice(i, 1);
                i--;
                break;
              }
            }
          }
        }

        // ターゲット到達
        const targetDistance = Math.sqrt((block.x - block.toArea.x) ** 2 + (block.y - block.toArea.y) ** 2);
        if (targetDistance <= AREA_RADIUS || block.distanceTraveled >= block.totalDistance) {
          const toArea = block.toArea;
          const movingVirus = block.virusCount;

          if (toArea.owner === block.owner) {
            toArea.virusCount += movingVirus;
            if (toArea.virusCount > MAX_VIRUS_COUNT) {
              toArea.virusCount = MAX_VIRUS_COUNT;
            }
          } else if (toArea.owner === 'neutral') {
            if (movingVirus > toArea.virusCount) {
              toArea.owner = block.owner;
              toArea.virusCount = movingVirus - toArea.virusCount;
            } else if (movingVirus === toArea.virusCount) {
              toArea.owner = 'neutral';
              toArea.virusCount = 0;
            } else {
              toArea.virusCount -= movingVirus;
            }
          } else {
            if (movingVirus > toArea.virusCount) {
              toArea.owner = block.owner;
              toArea.virusCount = movingVirus - toArea.virusCount;
            } else if (movingVirus === toArea.virusCount) {
              toArea.owner = 'neutral';
              toArea.virusCount = 0;
            } else {
              toArea.virusCount -= movingVirus;
            }
          }
          if (toArea.virusCount > MAX_VIRUS_COUNT) {
            toArea.virusCount = MAX_VIRUS_COUNT;
          }

          // ブロック削除
          attackBlocks.splice(i, 1);
          i--;
        }
      }
    }

    // ======================
    //   敵の行動
    // ======================
    function enemyAction() {
      const enemyAreas = areas.filter(a => a.owner === 'enemy' && a.virusCount > 0);
      enemyAreas.forEach(area => {
        const neighboringAreas = connections
          .filter(conn => conn.includes(area.id))
          .map(conn => (conn[0] === area.id ? conn[1] : conn[0]))
          .map(id => areas.find(a => a.id === id));

        if (!neighboringAreas.length) return;

        let targetArea;
        if (currentStage <= 5) {
          // ランダム攻撃
          targetArea = neighboringAreas[Math.floor(Math.random() * neighboringAreas.length)];
        } else {
          // プレイヤーのウイルス数が少ないエリア優先
          const playerAreas = neighboringAreas.filter(a => a.owner === 'player');
          if (playerAreas.length > 0) {
            targetArea = playerAreas.reduce(
              (minArea, a) => (a.virusCount < minArea.virusCount ? a : minArea),
              playerAreas[0]
            );
          } else {
            targetArea = neighboringAreas[Math.floor(Math.random() * neighboringAreas.length)];
          }
        }

        if (targetArea && area.virusCount > 0) {
          const enemyBlocksOnRoute = attackBlocks.filter(
            b => b.owner === 'enemy' && b.fromArea.id === area.id && b.toArea.id === targetArea.id
          );
          if (enemyBlocksOnRoute.length >= 3) return;

          const movingVirus = area.virusCount; // 全て移動
          if (movingVirus <= 0) return;
          area.virusCount -= movingVirus;
          createAttackBlock(area, targetArea, movingVirus, 'enemy');
        }
      });
    }

    // ======================
    //   勝敗判定
    // ======================
    function checkGameStatus() {
      const playerOwned = areas.filter(a => a.owner === 'player').length;
      const totalAreas = areas.length;

      if (playerOwned === 0) {
        clearInterval(gameInterval);
        attackBlocks = [];
        gameOverOverlay.style.display = 'flex';
      } else if (playerOwned === totalAreas) {
        clearInterval(gameInterval);
        attackBlocks = [];
        levelCompleteOverlay.style.display = 'flex';
      }
    }

    // ======================
    //   ゲームループ
    // ======================
    function gameLoop() {
      virusGrowthCounter += 50;
      enemyActionCounter += 50;

      if (virusGrowthCounter >= 1000) {
        increaseVirusCounts();
        virusGrowthCounter = 0;
      }
      if (enemyActionCounter >= 1000 && currentStage !== 0) {
        enemyAction();
        enemyActionCounter = 0;
      }

      updateAttackBlocks();
      checkGameStatus();
      drawAreas();
    }

    // ======================
    //   ウイルス増殖（上限あり）
    // ======================
    function increaseVirusCounts() {
      areas.forEach(a => {
        if (a.owner !== 'neutral') {
          a.virusCount += a.growthRate;
          if (a.virusCount > MAX_VIRUS_COUNT) {
            a.virusCount = MAX_VIRUS_COUNT;
          }
        }
      });
    }

    // ======================
    //   イベント設定
    // ======================
    retryLevelButton.addEventListener('touchend', (e) => {
      e.preventDefault();
      levelCompleteOverlay.style.display = 'none';
      startStage(currentStage);
    }, { passive: false });

    retryLevelButton.addEventListener('click', (e) => {
      e.preventDefault();
      levelCompleteOverlay.style.display = 'none';
      startStage(currentStage);
    });

    nextLevelButton.addEventListener('touchend', (e) => {
      e.preventDefault();
      levelCompleteOverlay.style.display = 'none';
      startStage(currentStage + 1);
    }, { passive: false });

    nextLevelButton.addEventListener('click', (e) => {
      e.preventDefault();
      levelCompleteOverlay.style.display = 'none';
      startStage(currentStage + 1);
    });

    restartButton.addEventListener('touchend', (e) => {
      e.preventDefault();
      gameOverOverlay.style.display = 'none';
      initGame();
    }, { passive: false });

    restartButton.addEventListener('click', (e) => {
      e.preventDefault();
      gameOverOverlay.style.display = 'none';
      initGame();
    });

    retryButton.addEventListener('touchend', (e) => {
      e.preventDefault();
      gameOverOverlay.style.display = 'none';
      startStage(currentStage);
    }, { passive: false });

    retryButton.addEventListener('click', (e) => {
      e.preventDefault();
      gameOverOverlay.style.display = 'none';
      startStage(currentStage);
    });

    // Prevent default scrolling behavior while touching the game area
    document.body.addEventListener('touchmove', function(e) {
      if (!e.target.closest('#gameContainer') && !e.target.closest('.overlay')) {
        // Allow scrolling outside the game area and overlays
        return;
      }
      e.preventDefault();
    }, { passive: false });

    // ゲーム開始
    window.addEventListener('load', () => {
      initGame();
      adjustCanvasAndRadius();
      drawAreas();
    });

    // 調整が必要な場合にリサイズ時にも対応
    window.addEventListener('resize', () => {
      adjustCanvasAndRadius();
      drawAreas();
    });
  </script>
</body>
</html>
