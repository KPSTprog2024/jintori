<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>陣取り・じんとり</title>

  <!-- モバイル向けビューポート設定（拡大/縮小の挙動など） -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

  <style>
    /* =========================
       ========  共通CSS  =======
       ========================= */
    body {
      margin: 0;
      padding: 0;
      background-color: #f0f0f0;
      font-family: sans-serif;
    }

    #mainContainer {
      position: relative;
      /* 横幅いっぱいにし、中央寄せにする */
      width: 100%;
      max-width: 900px; /* PCで見たときの最大幅を少し大きめにしてみる */
      margin: 0 auto;
    }

    #gameContainer {
      position: relative;
      /* もとのゲーム解像度は 800×600 だが、
         スマホで見たときにも拡大縮小されるように width: 100% を適用 */
      width: 100%;
      overflow: hidden;
    }

    /* キャンバスを拡大表示させる。
       内部の描画解像度は 800x600 で固定。
       見た目だけを拡大・縮小する。 */
    #gameCanvas {
      display: block;
      width: 100%;
      height: auto; 
      background-color: #fff;
      border: 1px solid #ccc;
    }

    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      /* キャンバスと同じアスペクト比に合わせる（800×600） */
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: none;
    }

    .content {
      position: relative;
      top: 10%;
      width: 80%;
      margin: 0 auto;
      text-align: center;
      color: #fff;
    }

    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 1.1rem;
      cursor: pointer;
    }

    /* Give Up ボタンのスタイルを変更 */
    #giveUpButton {
      position: absolute;
      bottom: 5px;
      left: 5px;
      z-index: 10;
      padding: 8px 12px;
      font-size: 1rem;
    }

    /* ステージ選択ボタンのスタイル */
    #stageSelection {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 5px;
    }

    .stageButton {
      width: 100px;
      margin: 5px;
    }
  </style>
</head>
<body>
  <div id="mainContainer">
    <div id="gameContainer">
      <!-- キャンバス: 内部解像度800x600, 見た目は可変 -->
      <canvas id="gameCanvas" width="800" height="600"></canvas>

      <!-- スタート画面 -->
      <div id="startScreen" class="overlay">
        <div class="content">
          <h2>陣取りゲームへようこそ！</h2>
          <p>ステージを選択してください：</p>
          <div id="stageSelection">
            <!-- 「チュートリアル＝ステージ1」としてボタン表記を合わせる -->
            <button class="stageButton" data-stage="1">ステージ 1</button>
            <button class="stageButton" data-stage="2">ステージ 2</button>
            <button class="stageButton" data-stage="3">ステージ 3</button>
            <button class="stageButton" data-stage="4">ステージ 4</button>
            <button class="stageButton" data-stage="5">ステージ 5</button>
            <button class="stageButton" data-stage="6">ステージ 6</button>
            <button class="stageButton" data-stage="7">ステージ 7</button>
            <button class="stageButton" data-stage="8">ステージ 8</button>
            <button class="stageButton" data-stage="9">ステージ 9</button>
            <button class="stageButton" data-stage="10">ステージ 10</button>
          </div>
        </div>
      </div>

      <!-- ステージクリア画面 -->
      <div id="levelComplete" class="overlay">
        <div class="content">
          <h2>ステージクリア！</h2>
          <button id="retryLevelButton">もう一回同じレベル</button>
          <button id="nextLevelButton">次のレベル</button>
        </div>
      </div>

      <!-- ゲームオーバー画面 -->
      <div id="gameOver" class="overlay">
        <div class="content">
          <h2>ゲームオーバー</h2>
          <button id="restartButton">最初に戻る</button>
          <button id="retryButton">もう一回同じレベル</button>
        </div>
      </div>
    </div>

    <!-- Give Up ボタンをゲーム画面左下に配置 -->
    <button id="giveUpButton">Give Up</button>
  </div>

  <script>
    /* =========================
       ========  ステージデータ  =======
       ========================= */
    const stages = [
      // index 0 → 「ステージ1: チュートリアル」
      {
        areas: [
          { id: 1, x: 200, y: 300, owner: 'player', virusCount: 10, growthRate: 1 },
          { id: 2, x: 400, y: 200, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 3, x: 400, y: 400, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 4, x: 600, y: 300, owner: 'neutral', virusCount: 5, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [2, 4],
          [1, 3],
          [3, 4],
        ],
      },
      // index 1 → ステージ2
      {
        areas: [
          { id: 1, x: 100, y: 300, owner: 'player', virusCount: 10, growthRate: 1 },
          { id: 2, x: 250, y: 150, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 3, x: 250, y: 450, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 4, x: 400, y: 300, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 5, x: 550, y: 150, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 6, x: 550, y: 450, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 7, x: 700, y: 300, owner: 'enemy', virusCount: 10, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
        ],
      },
      // index 2 → ステージ3
      {
        areas: [
          { id: 1, x: 100, y: 100, owner: 'player', virusCount: 15, growthRate: 1 },
          { id: 2, x: 100, y: 500, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 3, x: 400, y: 100, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 4, x: 400, y: 300, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 5, x: 400, y: 500, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 6, x: 700, y: 100, owner: 'enemy', virusCount: 15, growthRate: 1 },
          { id: 7, x: 700, y: 500, owner: 'neutral', virusCount: 5, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 5],
          [3, 4],
          [4, 5],
          [4, 7],
          [5, 7],
          [3, 6],
          [6, 7],
        ],
      },
      // index 3 → ステージ4
      {
        areas: [
          { id: 1, x: 400, y: 50, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 2, x: 250, y: 150, owner: 'player', virusCount: 20, growthRate: 1 },
          { id: 3, x: 550, y: 150, owner: 'enemy', virusCount: 20, growthRate: 1 },
          { id: 4, x: 400, y: 250, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 5, x: 250, y: 350, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 6, x: 550, y: 350, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 7, x: 400, y: 450, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 8, x: 400, y: 550, owner: 'neutral', virusCount: 5, growthRate: 2 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
          [7, 8],
        ],
      },
      // index 4 → ステージ5
      {
        areas: [
          { id: 1, x: 150, y: 300, owner: 'player', virusCount: 20, growthRate: 1 },
          { id: 2, x: 300, y: 150, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 3, x: 300, y: 450, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 4, x: 450, y: 300, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 5, x: 600, y: 150, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 6, x: 600, y: 450, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 7, x: 750, y: 300, owner: 'enemy', virusCount: 25, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
        ],
      },
      // index 5 → ステージ6
      {
        areas: [
          { id: 1, x: 400, y: 50, owner: 'player', virusCount: 20, growthRate: 1 },
          { id: 2, x: 200, y: 200, owner: 'enemy', virusCount: 10, growthRate: 2 },
          { id: 3, x: 600, y: 200, owner: 'neutral', virusCount: 20, growthRate: 2 },
          { id: 4, x: 400, y: 350, owner: 'neutral', virusCount: 20, growthRate: 1 },
          { id: 5, x: 200, y: 500, owner: 'enemy', virusCount: 25, growthRate: 1 },
          { id: 6, x: 600, y: 500, owner: 'player', virusCount: 10, growthRate: 2 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
        ],
      },
      // index 6 → ステージ7
      {
        areas: [
          { id: 1, x: 100, y: 100, owner: 'player', virusCount: 35, growthRate: 2 },
          { id: 2, x: 700, y: 100, owner: 'enemy', virusCount: 40, growthRate: 1 },
          { id: 3, x: 400, y: 200, owner: 'neutral', virusCount: 25, growthRate: 2 },
          { id: 4, x: 250, y: 350, owner: 'neutral', virusCount: 25, growthRate: 1 },
          { id: 5, x: 550, y: 350, owner: 'neutral', virusCount: 25, growthRate: 2 },
          { id: 6, x: 100, y: 500, owner: 'neutral', virusCount: 25, growthRate: 2 },
          { id: 7, x: 700, y: 500, owner: 'enemy', virusCount: 20, growthRate: 1 },
        ],
        connections: [
          [1, 3],
          [2, 3],
          [3, 4],
          [3, 5],
          [4, 6],
          [5, 7],
        ],
      },
      // index 7 → ステージ8
      {
        areas: [
          { id: 1, x: 400, y: 50, owner: 'player', virusCount: 40, growthRate: 1 },
          { id: 2, x: 250, y: 150, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 3, x: 550, y: 150, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 4, x: 250, y: 350, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 5, x: 550, y: 350, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 6, x: 250, y: 550, owner: 'enemy', virusCount: 25, growthRate: 1 },
          { id: 7, x: 550, y: 550, owner: 'enemy', virusCount: 25, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 5],
          [4, 6],
          [5, 7],
          [4, 5],
        ],
      },
      // index 8 → ステージ9
      {
        areas: [
          { id: 1, x: 100, y: 300, owner: 'player', virusCount: 25, growthRate: 1 },
          { id: 2, x: 250, y: 150, owner: 'neutral', virusCount: 20, growthRate: 2 },
          { id: 3, x: 250, y: 450, owner: 'neutral', virusCount: 35, growthRate: 2 },
          { id: 4, x: 400, y: 300, owner: 'neutral', virusCount: 40, growthRate: 2 },
          { id: 5, x: 550, y: 150, owner: 'neutral', virusCount: 35, growthRate: 2 },
          { id: 6, x: 550, y: 450, owner: 'neutral', virusCount: 20, growthRate: 2 },
          { id: 7, x: 700, y: 300, owner: 'enemy', virusCount: 30, growthRate: 2 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
          [2, 5],
          [3, 6],
        ],
      },
      // index 9 → ステージ10
      {
        areas: [
          { id: 1, x: 400, y: 50, owner: 'player', virusCount: 40, growthRate: 1 },
          { id: 2, x: 200, y: 200, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 3, x: 600, y: 200, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 4, x: 400, y: 350, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 5, x: 200, y: 500, owner: 'enemy', virusCount: 35, growthRate: 1 },
          { id: 6, x: 600, y: 500, owner: 'enemy', virusCount: 35, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [2, 5],
          [3, 6],
        ],
      },
      // index 10 → ステージ11(ランダムステージの呼び出し対象になるサンプル)
      {
        areas: [
          { id: 1, x: 100, y: 100, owner: 'player', virusCount: 25, growthRate: 2 },
          { id: 2, x: 100, y: 500, owner: 'neutral', virusCount: 15, growthRate: 1 },
          { id: 3, x: 400, y: 100, owner: 'neutral', virusCount: 15, growthRate: 2 },
          { id: 4, x: 250, y: 300, owner: 'neutral', virusCount: 15, growthRate: 2 },
          { id: 5, x: 550, y: 300, owner: 'neutral', virusCount: 15, growthRate: 2 },
          { id: 6, x: 400, y: 500, owner: 'neutral', virusCount: 15, growthRate: 1 },
          { id: 7, x: 700, y: 100, owner: 'enemy', virusCount: 20, growthRate: 1 },
          { id: 8, x: 700, y: 500, owner: 'enemy', virusCount: 20, growthRate: 1 },
        ],
        connections: [
          [1, 3],
          [1, 4],
          [2, 4],
          [2, 6],
          [3, 5],
          [4, 5],
          [5, 7],
          [6, 5],
          [6, 8],
          [7, 5],
          [8, 6],
        ],
      },
    ];

    /* =========================
       ========  ゲーム本体  =======
       ========================= */

    // キャンバスとコンテキストの取得
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // オーバーレイ要素の取得
    const startScreen = document.getElementById('startScreen');
    const levelCompleteOverlay = document.getElementById('levelComplete');
    const nextLevelButton = document.getElementById('nextLevelButton');
    const retryLevelButton = document.getElementById('retryLevelButton');
    const gameOverOverlay = document.getElementById('gameOver');
    const retryButton = document.getElementById('retryButton');
    const restartButton = document.getElementById('restartButton');

    // ステージ選択ボタンの取得
    const stageButtons = document.querySelectorAll('.stageButton');

    // ゲーム状態の変数
    let currentStage = 0;       // 1〜10 ボタン押下時に設定される
    let areas = [];
    let connections = [];
    let selectedArea = null;
    let gameInterval;

    // 攻撃ブロックを管理する配列
    let attackBlocks = [];

    // エリアの半径（スマホでも見やすいよう少し大きめに）
    const AREA_RADIUS = 50;

    // ウイルス増殖と敵行動のタイミング管理
    let virusGrowthCounter = 0;
    let enemyActionCounter = 0;

    // 攻撃ブロックの移動速度
    const ATTACK_BLOCK_SPEED = 2; // 移動速度

    // ウイルス数の上限
    const MAX_VIRUS_COUNT = 40;

    // Give Up ボタンの要素と状態
    const giveUpButton = document.getElementById('giveUpButton');
    let giveUpState = 'giveUp'; // 'giveUp' または 'restart'

    // ======================
    //   初期化関数
    // ======================
    function initGame() {
      startScreen.style.display = 'block';
      // Give Up ボタンを非表示にする
      giveUpButton.style.display = 'none';
      // ボタンの初期状態を設定
      giveUpButton.textContent = 'Give Up';
      giveUpButton.style.backgroundColor = '';
      giveUpState = 'giveUp';
    }

    // ======================
    // ステージ選択ボタンのクリック設定
    // ======================
    stageButtons.forEach(button => {
      button.addEventListener('click', () => {
        const selectedStage = parseInt(button.getAttribute('data-stage'), 10);
        startScreen.style.display = 'none';
        startStage(selectedStage);
      });
    });

    // ======================
    //  Give Up ボタン
    // ======================
    giveUpButton.addEventListener('click', () => {
      if (giveUpState === 'giveUp') {
        // ボタンを「Restart」に変更
        giveUpButton.textContent = 'Restart';
        giveUpButton.style.backgroundColor = '#f00';
        giveUpState = 'restart';
      } else if (giveUpState === 'restart') {
        // 現在のステージを再スタート
        giveUpButton.textContent = 'Give Up';
        giveUpButton.style.backgroundColor = '';
        giveUpState = 'giveUp';
        startStage(currentStage);
      }
    });

    // ======================
    //   ステージ開始
    // ======================
    function startStage(stageNumber) {
      currentStage = stageNumber; // 1,2,3,...の値が入ってくる
      attackBlocks = []; // 攻撃ブロックをクリア
      setupStage(stageNumber);
      drawAreas();
      if (gameInterval) clearInterval(gameInterval);
      virusGrowthCounter = 0;
      enemyActionCounter = 0;

      // 50msごとにゲームループを呼び出し
      gameInterval = setInterval(gameLoop, 50);

      // ゲーム開始時に Give Up ボタンを表示
      giveUpButton.style.display = 'block';
      giveUpButton.textContent = 'Give Up';
      giveUpButton.style.backgroundColor = '';
      giveUpState = 'giveUp';
    }

    // ======================
    //   ステージのセットアップ
    // ======================
    function setupStage(stageNumber) {
      /* 
         ボタンdata-stage="1" なら → stages[0] を参照する
         ボタンdata-stage="2" なら → stages[1] を参照する
         ...
         ボタンdata-stage="10"なら → stages[9] を参照する
         ボタンdata-stage="11"以降はランダムステージ
       */
      const index = stageNumber - 1; // 例：ステージ1→index=0
      if (index < stages.length && index >= 0) {
        // 固定デザインのステージをロード
        const stageData = stages[index];
        areas = stageData.areas.map(area => ({ ...area }));
        connections = stageData.connections.map(conn => [...conn]);
      } else {
        // ランダムステージ（ステージ11以降）
        createRandomStage(stageNumber);
      }
      selectedArea = null;
    }

    // ======================
    //   ランダムステージ生成
    // ======================
    function createRandomStage(stageNumber) {
      const numAreas = Math.min(15, 5 + Math.floor(stageNumber / 2)); 
      areas = [];
      connections = [];

      // グリッドのサイズを決定
      const gridSize = Math.ceil(Math.sqrt(numAreas));
      const gridSpacingX = (canvas.width - 2 * AREA_RADIUS) / (gridSize - 1);
      const gridSpacingY = (canvas.height - 2 * AREA_RADIUS) / (gridSize - 1);

      // グリッド上の座標リスト
      let gridPositions = [];
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const x = AREA_RADIUS + i * gridSpacingX;
          const y = AREA_RADIUS + j * gridSpacingY;
          gridPositions.push({ x, y });
        }
      }

      // エリアを生成
      for (let i = 0; i < numAreas; i++) {
        const index = Math.floor(Math.random() * gridPositions.length);
        const pos = gridPositions.splice(index, 1)[0];

        const area = {
          id: i + 1,
          x: pos.x,
          y: pos.y,
          owner: 'neutral',
          virusCount: Math.floor(Math.random() * 20) + 10, // 10〜30
          growthRate: Math.floor(Math.random() * 3) + 1,   // 1〜3
        };
        areas.push(area);
      }

      // プレイヤーのエリア
      const playerArea = areas[0];
      playerArea.owner = 'player';
      playerArea.virusCount = 30 + stageNumber * 2; 
      playerArea.growthRate = 1;

      // 敵のエリア
      const enemyArea = areas[areas.length - 1];
      enemyArea.owner = 'enemy';
      enemyArea.virusCount = 30 + stageNumber * 2; 
      enemyArea.growthRate = 1;

      // エリア間の接続
      const areaMap = new Map();
      areas.forEach(area => {
        areaMap.set(`${area.x},${area.y}`, area);
      });

      let horizontalConnections = 0;
      let verticalConnections = 0;
      let diagonalConnections = 0;

      for (let area of areas) {
        // 右隣(横方向)
        const rightNeighbor = areaMap.get(`${area.x + gridSpacingX},${area.y}`);
        if (rightNeighbor) {
          connections.push([area.id, rightNeighbor.id]);
          horizontalConnections++;
        }
        // 下隣(縦方向)
        const bottomNeighbor = areaMap.get(`${area.x},${area.y + gridSpacingY}`);
        if (bottomNeighbor) {
          connections.push([area.id, bottomNeighbor.id]);
          verticalConnections++;
        }
        // 斜め右下
        const diagonalNeighbor = areaMap.get(`${area.x + gridSpacingX},${area.y + gridSpacingY}`);
        if (diagonalNeighbor && diagonalConnections < Math.floor((horizontalConnections + verticalConnections) / 2)) {
          connections.push([area.id, diagonalNeighbor.id]);
          diagonalConnections++;
        }
      }
    }

    // ======================
    //   画面描画
    // ======================
    function drawAreas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ステージ番号を左上に表示
      ctx.fillStyle = 'black';
      ctx.font = '24px Arial';  // 文字サイズやや大きく
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(`ステージ ${currentStage}`, 10, 10);

      // エリア間の線を描画
      connections.forEach(conn => {
        const area1 = areas.find(area => area.id === conn[0]);
        const area2 = areas.find(area => area.id === conn[1]);
        if (!area1 || !area2) return;

        // 線がエリアの外縁から始まるように調整
        const angle = Math.atan2(area2.y - area1.y, area2.x - area1.x);
        const x1 = area1.x + AREA_RADIUS * Math.cos(angle);
        const y1 = area1.y + AREA_RADIUS * Math.sin(angle);
        const x2 = area2.x - AREA_RADIUS * Math.cos(angle);
        const y2 = area2.y - AREA_RADIUS * Math.sin(angle);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = '#ccc';
        ctx.stroke();
      });

      // 攻撃ブロックの描画
      attackBlocks.forEach(block => {
        ctx.beginPath();
        ctx.arc(block.x, block.y, 12, 0, Math.PI * 2);
        ctx.fillStyle = block.owner === 'player' ? 'red' : 'orange';
        ctx.fill();

        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(block.virusCount, block.x, block.y);
      });

      // エリアを描画
      areas.forEach(area => {
        ctx.beginPath();
        ctx.arc(area.x, area.y, AREA_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle =
          area.owner === 'player' ? 'red' :
          area.owner === 'enemy' ? 'orange' : 'white';
        ctx.fill();

        // 縁取りの設定
        let lineWidth = 1;
        let strokeStyle = 'black';

        if (selectedArea === area) {
          // 選択したエリア
          lineWidth = 5;
          strokeStyle = 'darkred';
        } else if (selectedArea && isNeighbor(selectedArea, area)) {
          // 隣接するすべてのエリア
          lineWidth = 5;
          strokeStyle = 'darkblue';
        }

        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = strokeStyle;
        ctx.stroke();

        // ウイルス数と増殖率を表示
        ctx.fillStyle = 'black';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(area.virusCount, area.x, area.y + 5);
        ctx.fillText(`×${area.growthRate}`, area.x, area.y + 30);
      });
    }

    // ======================
    //   ウイルス増殖（上限あり）
    // ======================
    function increaseVirusCounts() {
      areas.forEach(area => {
        if (area.owner !== 'neutral') {
          area.virusCount += area.growthRate;
          if (area.virusCount > MAX_VIRUS_COUNT) {
            area.virusCount = MAX_VIRUS_COUNT;
          }
        }
      });
    }

    // ======================
    //   エリアクリック処理
    // ======================
    canvas.addEventListener('click', function(event) {
      const rect = canvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;

      const clickedArea = areas.find(area => {
        const dx = area.x - clickX;
        const dy = area.y - clickY;
        return Math.sqrt(dx * dx + dy * dy) < AREA_RADIUS;
      });

      if (clickedArea) {
        if (!selectedArea) {
          // 自エリアを選択
          if (clickedArea.owner === 'player' && clickedArea.virusCount > 0) {
            selectedArea = clickedArea;
            drawAreas();
          }
        } else {
          // 移動先を選択
          if (isNeighbor(selectedArea, clickedArea)) {
            moveVirus(selectedArea.id, clickedArea.id);
            selectedArea = null;
            drawAreas();
          } else {
            // 隣接していない場合は選択を解除
            selectedArea = null;
            drawAreas();
          }
        }
      } else {
        // 何もない場所をクリックした場合、選択を解除
        selectedArea = null;
        drawAreas();
      }
    });

    // ======================
    //   エリアが隣接しているかを確認
    // ======================
    function isNeighbor(fromArea, toArea) {
      return connections.some(conn =>
        (conn[0] === fromArea.id && conn[1] === toArea.id) ||
        (conn[1] === fromArea.id && conn[0] === toArea.id)
      );
    }

    // ======================
    //   ウイルス移動 → 攻撃ブロック作成
    // ======================
    function moveVirus(fromId, toId) {
      const fromArea = areas.find(area => area.id === fromId);
      const toArea = areas.find(area => area.id === toId);

      if (!fromArea || !toArea) return;
      if (fromArea.owner !== 'player') return;

      // 同一経路上の自分の攻撃ブロック数をカウント
      const playerBlocksOnRoute = attackBlocks.filter(block =>
        block.owner === 'player' &&
        block.fromArea.id === fromArea.id &&
        block.toArea.id === toArea.id
      );
      // 同一路線に3つ以上のブロックがある場合は出さない
      if (playerBlocksOnRoute.length >= 3) return;

      const movingVirus = fromArea.virusCount;
      if (movingVirus <= 0) return;
      fromArea.virusCount -= movingVirus;

      createAttackBlock(fromArea, toArea, movingVirus, 'player');
    }

    // ======================
    //   攻撃ブロック作成 共通関数
    // ======================
    function createAttackBlock(fromArea, toArea, virusCount, owner) {
      const dx = toArea.x - fromArea.x;
      const dy = toArea.y - fromArea.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const unitX = dx / distance;
      const unitY = dy / distance;

      const startX = fromArea.x + AREA_RADIUS * unitX;
      const startY = fromArea.y + AREA_RADIUS * unitY;
      const endX = toArea.x - AREA_RADIUS * unitX;
      const endY = toArea.y - AREA_RADIUS * unitY;
      const totalDistance = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);

      attackBlocks.push({
        owner: owner,
        virusCount: virusCount,
        fromArea: fromArea,
        toArea: toArea,
        x: startX,
        y: startY,
        dx: unitX,
        dy: unitY,
        totalDistance: totalDistance,
        distanceTraveled: 0,
        speed: ATTACK_BLOCK_SPEED,
      });
    }

    // ======================
    //   攻撃ブロック更新
    // ======================
    function updateAttackBlocks() {
      for (let i = 0; i < attackBlocks.length; i++) {
        const block = attackBlocks[i];
        // 移動
        block.distanceTraveled += block.speed;
        block.x += block.dx * block.speed;
        block.y += block.dy * block.speed;

        // 攻撃ブロック同士の衝突判定
        for (let j = i + 1; j < attackBlocks.length; j++) {
          const otherBlock = attackBlocks[j];

          // 同一経路 or 逆向き経路の場合のみ衝突判定
          const samePath =
            (block.fromArea.id === otherBlock.fromArea.id && block.toArea.id === otherBlock.toArea.id) ||
            (block.fromArea.id === otherBlock.toArea.id && block.toArea.id === otherBlock.fromArea.id);
          if (!samePath) continue;

          // 異なる所有者の場合のみ衝突判定
          if (block.owner !== otherBlock.owner) {
            const dx = block.x - otherBlock.x;
            const dy = block.y - otherBlock.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            // 半径12+12 = 24程度で衝突とみなす（ややゆるめ）
            if (distance < 24) {
              if (block.virusCount > otherBlock.virusCount) {
                block.virusCount -= otherBlock.virusCount;
                attackBlocks.splice(j, 1);
                j--;
              } else if (block.virusCount < otherBlock.virusCount) {
                otherBlock.virusCount -= block.virusCount;
                attackBlocks.splice(i, 1);
                i--;
                break;
              } else {
                // 同数なら両方消える
                attackBlocks.splice(j, 1);
                attackBlocks.splice(i, 1);
                i--;
                break;
              }
            }
          }
        }

        // ターゲットエリアに到達したか
        const targetDistance = Math.sqrt(
          (block.x - block.toArea.x) ** 2 + (block.y - block.toArea.y) ** 2
        );
        if (targetDistance <= AREA_RADIUS || block.distanceTraveled >= block.totalDistance) {
          // 攻撃ブロック到達処理
          const toArea = block.toArea;
          const movingVirus = block.virusCount;

          if (toArea.owner === block.owner) {
            // 自エリアに補給
            toArea.virusCount += movingVirus;
            if (toArea.virusCount > MAX_VIRUS_COUNT) {
              toArea.virusCount = MAX_VIRUS_COUNT;
            }
          } else if (toArea.owner === 'neutral') {
            // 中立エリア占領
            if (movingVirus > toArea.virusCount) {
              toArea.owner = block.owner;
              toArea.virusCount = movingVirus - toArea.virusCount;
            } else if (movingVirus === toArea.virusCount) {
              toArea.owner = 'neutral';
              toArea.virusCount = 0;
            } else {
              toArea.virusCount -= movingVirus;
            }
          } else {
            // 敵エリアへの攻撃
            if (movingVirus > toArea.virusCount) {
              toArea.owner = block.owner;
              toArea.virusCount = movingVirus - toArea.virusCount;
            } else if (movingVirus === toArea.virusCount) {
              toArea.owner = 'neutral';
              toArea.virusCount = 0;
            } else {
              toArea.virusCount -= movingVirus;
            }
          }

          if (toArea.virusCount > MAX_VIRUS_COUNT) {
            toArea.virusCount = MAX_VIRUS_COUNT;
          }

          // 攻撃ブロックの削除
          attackBlocks.splice(i, 1);
          i--;
        }
      }
    }

    // ======================
    //   敵の行動
    // ======================
    function enemyAction() {
      const enemyAreas = areas.filter(area => area.owner === 'enemy' && area.virusCount > 0);
      enemyAreas.forEach(area => {
        // 隣接するエリアを取得
        const neighboringAreas = connections
          .filter(conn => conn.includes(area.id))
          .map(conn => conn[0] === area.id ? conn[1] : conn[0])
          .map(id => areas.find(a => a.id === id));

        if (!neighboringAreas.length) return;

        let targetArea;
        if (currentStage <= 5) {
          // ランダムに攻撃
          targetArea = neighboringAreas[Math.floor(Math.random() * neighboringAreas.length)];
        } else {
          // プレイヤーのウイルス数が少ないエリアを優先攻撃
          const playerAreas = neighboringAreas.filter(a => a.owner === 'player');
          if (playerAreas.length > 0) {
            targetArea = playerAreas.reduce(
              (minArea, a) => (a.virusCount < minArea.virusCount ? a : minArea),
              playerAreas[0]
            );
          } else {
            targetArea = neighboringAreas[Math.floor(Math.random() * neighboringAreas.length)];
          }
        }

        if (targetArea && area.virusCount > 0) {
          // 同一経路上に3つ以上の敵ブロックがある場合は出さない
          const enemyBlocksOnRoute = attackBlocks.filter(block =>
            block.owner === 'enemy' &&
            block.fromArea.id === area.id &&
            block.toArea.id === targetArea.id
          );
          if (enemyBlocksOnRoute.length >= 3) return;

          const movingVirus = area.virusCount;
          area.virusCount -= movingVirus;

          createAttackBlock(area, targetArea, movingVirus, 'enemy');
        }
      });
    }

    // ======================
    //   勝敗判定
    // ======================
    function checkGameStatus() {
      const playerOwned = areas.filter(area => area.owner === 'player').length;
      const totalAreas = areas.length;

      if (playerOwned === 0) {
        // プレイヤーのエリアがなくなったらゲームオーバー
        clearInterval(gameInterval);
        attackBlocks = [];
        gameOverOverlay.style.display = 'block';
      } else if (playerOwned === totalAreas) {
        // 全エリアプレイヤー所有ならステージクリア
        clearInterval(gameInterval);
        attackBlocks = [];
        levelCompleteOverlay.style.display = 'block';
      }
    }

    // ======================
    //   ゲームループ
    // ======================
    function gameLoop() {
      virusGrowthCounter += 50; 
      enemyActionCounter += 50;

      if (virusGrowthCounter >= 1000) { 
        increaseVirusCounts();
        virusGrowthCounter = 0;
      }

      // ステージ0は存在しないため、currentStage !== 0 はチェック不要だが、一応残してもOK
      if (enemyActionCounter >= 1000 && currentStage !== 0) {
        enemyAction();
        enemyActionCounter = 0;
      }

      updateAttackBlocks();
      checkGameStatus();
      drawAreas();
    }

    // ======================
    // ステージクリア時のボタンイベント
    // ======================
    retryLevelButton.addEventListener('click', () => {
      levelCompleteOverlay.style.display = 'none';
      startStage(currentStage);
    });
    nextLevelButton.addEventListener('click', () => {
      levelCompleteOverlay.style.display = 'none';
      startStage(currentStage + 1);
    });

    // ======================
    // ゲームオーバー時のボタンイベント
    // ======================
    restartButton.addEventListener('click', () => {
      gameOverOverlay.style.display = 'none';
      initGame();
    });
    retryButton.addEventListener('click', () => {
      gameOverOverlay.style.display = 'none';
      startStage(currentStage);
    });

    // ゲームの開始
    initGame();
  </script>
</body>
</html>
