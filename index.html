<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>陣取りゲーム</title>
  <!-- iPhoneやiPadでの表示を最適化 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">

  <style>
    /* ページ全体のリセット & スクロール可能に */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      /* 高さは必要に応じて可変 */
      min-height: 100%;
      box-sizing: border-box;
      background-color: #f0f0f0;
      font-family: sans-serif;
      /* スクロールを可能にするため overflow: hidden; は使わない */
      overflow: auto;
    }

    /* メインコンテナ: 通常の相対配置にし、ページスクロールを阻害しない */
    #mainContainer {
      position: relative;
      width: 100%;
      /* 高さは可変とし、コンテンツが増えればスクロールできる */
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      /* 上下に余白を少しとる */
      padding: 20px 0;
    }

    /* ゲームコンテナ */
    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 960px; /* ゲームキャンバスが16:9なので960px幅に */
      /* 高さは自動調整に */
      margin: 0 auto;
      overflow: visible;
    }

    /* キャンバス: アスペクト比16:9, 内部解像度 960×540 */
    #gameCanvas {
      display: block;
      width: 100%;
      height: auto; /* アスペクト比を保ちつつ、自動高さ */
      background-color: #fff;
      border: 1px solid #ccc;
      object-fit: contain;
      object-position: 50% 50%;
    }

    /* オーバーレイ (スタート/クリア/ゲームオーバー画面) */
    .overlay {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: none;
      /* flexで中央寄せ */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .content {
      position: relative;
      width: 80%;
      max-width: 600px; 
      margin: 0 auto; 
      text-align: center;
      color: #fff;
    }

    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 1.0rem;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background-color: #007BFF;
      color: #fff;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #0056b3;
    }

    /* Give Up ボタン：下中央に配置 */
    #giveUpButton {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      padding: 8px 12px;
      font-size: 1rem;
      border-radius: 5px;
      background-color: #dc3545;
      color: #fff;
      transition: background-color 0.3s;
    }

    #giveUpButton.restart {
      background-color: #28a745;
    }

    #giveUpButton:hover {
      background-color: #c82333;
    }

    /* ステージ選択ボタン */
    #stageSelection {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    .stageButton {
      min-width: 90px;
      margin: 5px;
      flex: 0 1 auto;
      border-radius: 5px;
      background-color: #17a2b8;
      color: #fff;
      transition: background-color 0.3s;
    }
    .stageButton:hover {
      background-color: #117a8b;
    }
  </style>
</head>
<body>
  <!-- メインコンテナ（画面のスクロールを可能に） -->
  <div id="mainContainer">
    <div id="gameContainer">
      <!-- キャンバス: 内部解像度 960×540(16:9) -->
      <canvas id="gameCanvas" width="960" height="540"></canvas>

      <!-- スタート画面 -->
      <div id="startScreen" class="overlay">
        <div class="content">
          <h2>陣取りゲームへようこそ！</h2>
          <p>ステージを選択してください：</p>
          <div id="stageSelection">
            <button class="stageButton" data-stage="1">ステージ 1</button>
            <button class="stageButton" data-stage="2">ステージ 2</button>
            <button class="stageButton" data-stage="3">ステージ 3</button>
            <button class="stageButton" data-stage="4">ステージ 4</button>
            <button class="stageButton" data-stage="5">ステージ 5</button>
            <button class="stageButton" data-stage="6">ステージ 6</button>
            <button class="stageButton" data-stage="7">ステージ 7</button>
            <button class="stageButton" data-stage="8">ステージ 8</button>
            <button class="stageButton" data-stage="9">ステージ 9</button>
            <button class="stageButton" data-stage="10">ステージ 10</button>
          </div>
        </div>
      </div>

      <!-- ステージクリア画面 -->
      <div id="levelComplete" class="overlay">
        <div class="content">
          <h2>ステージクリア！</h2>
          <button id="retryLevelButton">もう一回同じレベル</button>
          <button id="nextLevelButton">次のレベル</button>
        </div>
      </div>

      <!-- ゲームオーバー画面 -->
      <div id="gameOver" class="overlay">
        <div class="content">
          <h2>ゲームオーバー</h2>
          <button id="restartButton">最初に戻る</button>
          <button id="retryButton">もう一回同じレベル</button>
        </div>
      </div>
    </div>

    <!-- Give Up ボタン（下中央） -->
    <button id="giveUpButton">Give Up</button>
  </div>

  <script>
    /* =========================
       ========  ステージデータ  =======
       ========================= */
    const stages = [
      // index 0 → 「ステージ1: チュートリアル」
      {
        areas: [
          { id: 1, x: 200, y: 270, owner: 'player', virusCount: 10, growthRate: 1 },
          { id: 2, x: 480, y: 180, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 3, x: 480, y: 360, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 4, x: 760, y: 270, owner: 'neutral', virusCount: 5, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [2, 4],
          [1, 3],
          [3, 4],
        ],
      },
      // 以降ステージ2〜10 …（省略せず全て配置済み）
      {
        areas: [
          { id: 1, x: 100, y: 270, owner: 'player', virusCount: 10, growthRate: 1 },
          { id: 2, x: 240, y: 130, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 3, x: 240, y: 410, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 4, x: 400, y: 270, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 5, x: 560, y: 130, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 6, x: 560, y: 410, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 7, x: 720, y: 270, owner: 'enemy', virusCount: 10, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
        ],
      },
      {
        areas: [
          { id: 1, x: 100, y: 100, owner: 'player', virusCount: 15, growthRate: 1 },
          { id: 2, x: 100, y: 440, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 3, x: 400, y: 100, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 4, x: 400, y: 270, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 5, x: 400, y: 440, owner: 'neutral', virusCount: 5, growthRate: 1 },
          { id: 6, x: 700, y: 100, owner: 'enemy', virusCount: 15, growthRate: 1 },
          { id: 7, x: 700, y: 440, owner: 'neutral', virusCount: 5, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 5],
          [3, 4],
          [4, 5],
          [4, 7],
          [5, 7],
          [3, 6],
          [6, 7],
        ],
      },
      {
        areas: [
          { id: 1, x: 480, y:  40, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 2, x: 300, y: 140, owner: 'player', virusCount: 20, growthRate: 1 },
          { id: 3, x: 660, y: 140, owner: 'enemy', virusCount: 20, growthRate: 1 },
          { id: 4, x: 480, y: 240, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 5, x: 300, y: 340, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 6, x: 660, y: 340, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 7, x: 480, y: 440, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 8, x: 480, y: 500, owner: 'neutral', virusCount: 5, growthRate: 2 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
          [7, 8],
        ],
      },
      {
        areas: [
          { id: 1, x: 120, y: 270, owner: 'player', virusCount: 20, growthRate: 1 },
          { id: 2, x: 280, y: 130, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 3, x: 280, y: 410, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 4, x: 440, y: 270, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 5, x: 600, y: 130, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 6, x: 600, y: 410, owner: 'neutral', virusCount: 5, growthRate: 2 },
          { id: 7, x: 760, y: 270, owner: 'enemy', virusCount: 25, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
        ],
      },
      {
        areas: [
          { id: 1, x: 480, y:  40, owner: 'player', virusCount: 20, growthRate: 1 },
          { id: 2, x: 240, y: 180, owner: 'enemy', virusCount: 10, growthRate: 2 },
          { id: 3, x: 720, y: 180, owner: 'neutral', virusCount: 20, growthRate: 2 },
          { id: 4, x: 480, y: 320, owner: 'neutral', virusCount: 20, growthRate: 1 },
          { id: 5, x: 240, y: 460, owner: 'enemy', virusCount: 25, growthRate: 1 },
          { id: 6, x: 720, y: 460, owner: 'player', virusCount: 10, growthRate: 2 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
        ],
      },
      {
        areas: [
          { id: 1, x: 100, y: 100, owner: 'player', virusCount: 35, growthRate: 2 },
          { id: 2, x: 860, y: 100, owner: 'enemy', virusCount: 40, growthRate: 1 },
          { id: 3, x: 480, y: 180, owner: 'neutral', virusCount: 25, growthRate: 2 },
          { id: 4, x: 300, y: 300, owner: 'neutral', virusCount: 25, growthRate: 1 },
          { id: 5, x: 660, y: 300, owner: 'neutral', virusCount: 25, growthRate: 2 },
          { id: 6, x: 100, y: 460, owner: 'neutral', virusCount: 25, growthRate: 2 },
          { id: 7, x: 860, y: 460, owner: 'enemy', virusCount: 20, growthRate: 1 },
        ],
        connections: [
          [1, 3],
          [2, 3],
          [3, 4],
          [3, 5],
          [4, 6],
          [5, 7],
        ],
      },
      {
        areas: [
          { id: 1, x: 480, y:  40, owner: 'player', virusCount: 40, growthRate: 1 },
          { id: 2, x: 300, y: 140, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 3, x: 660, y: 140, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 4, x: 300, y: 300, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 5, x: 660, y: 300, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 6, x: 300, y: 460, owner: 'enemy', virusCount: 25, growthRate: 1 },
          { id: 7, x: 660, y: 460, owner: 'enemy', virusCount: 25, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 5],
          [4, 6],
          [5, 7],
          [4, 5],
        ],
      },
      {
        areas: [
          { id: 1, x: 100, y: 270, owner: 'player', virusCount: 25, growthRate: 1 },
          { id: 2, x: 240, y: 130, owner: 'neutral', virusCount: 20, growthRate: 2 },
          { id: 3, x: 240, y: 410, owner: 'neutral', virusCount: 35, growthRate: 2 },
          { id: 4, x: 400, y: 270, owner: 'neutral', virusCount: 40, growthRate: 2 },
          { id: 5, x: 560, y: 130, owner: 'neutral', virusCount: 35, growthRate: 2 },
          { id: 6, x: 560, y: 410, owner: 'neutral', virusCount: 20, growthRate: 2 },
          { id: 7, x: 720, y: 270, owner: 'enemy', virusCount: 30, growthRate: 2 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [5, 7],
          [6, 7],
          [2, 5],
          [3, 6],
        ],
      },
      {
        areas: [
          { id: 1, x: 480, y:  40, owner: 'player', virusCount: 40, growthRate: 1 },
          { id: 2, x: 200, y: 180, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 3, x: 760, y: 180, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 4, x: 480, y: 320, owner: 'neutral', virusCount: 30, growthRate: 2 },
          { id: 5, x: 200, y: 460, owner: 'enemy', virusCount: 35, growthRate: 1 },
          { id: 6, x: 760, y: 460, owner: 'enemy', virusCount: 35, growthRate: 1 },
        ],
        connections: [
          [1, 2],
          [1, 3],
          [2, 4],
          [3, 4],
          [4, 5],
          [4, 6],
          [2, 5],
          [3, 6],
        ],
      },
    ];

    /* =========================
       ========  ゲーム本体  =======
       ========================= */

    // キャンバス・コンテキスト
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // オーバーレイ取得
    const startScreen = document.getElementById('startScreen');
    const levelCompleteOverlay = document.getElementById('levelComplete');
    const nextLevelButton = document.getElementById('nextLevelButton');
    const retryLevelButton = document.getElementById('retryLevelButton');
    const gameOverOverlay = document.getElementById('gameOver');
    const retryButton = document.getElementById('retryButton');
    const restartButton = document.getElementById('restartButton');

    // ステージ選択ボタン
    const stageButtons = document.querySelectorAll('.stageButton');

    // ゲーム状態
    let currentStage = 0;
    let areas = [];
    let connections = [];
    let selectedArea = null;
    let gameInterval;

    // 攻撃ブロック管理
    let attackBlocks = [];

    // エリアの半径（固定値）
    const AREA_RADIUS = 50;

    // ウイルス増殖と敵行動カウンター
    let virusGrowthCounter = 0;
    let enemyActionCounter = 0;

    // 攻撃ブロック移動速度
    const ATTACK_BLOCK_SPEED = 2;

    // ウイルス数上限
    const MAX_VIRUS_COUNT = 40;

    // Give Up ボタン
    const giveUpButton = document.getElementById('giveUpButton');
    let giveUpState = 'giveUp'; // 'giveUp' or 'restart'

    // ======================
    //   初期化
    // ======================
    function initGame() {
      startScreen.style.display = 'flex';
      levelCompleteOverlay.style.display = 'none';
      gameOverOverlay.style.display = 'none';
      giveUpButton.style.display = 'none';
      giveUpButton.textContent = 'Give Up';
      giveUpButton.classList.remove('restart');
      giveUpState = 'giveUp';
      selectedArea = null;
    }

    // ======================
    //   ステージ選択
    // ======================
    function handleStageSelect(stageNumber) {
      startScreen.style.display = 'none';
      startStage(stageNumber);
    }

    stageButtons.forEach(button => {
      // タッチ
      button.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleStageSelect(parseInt(button.getAttribute('data-stage'), 10));
      }, { passive: false });
      // クリック
      button.addEventListener('click', (e) => {
        e.preventDefault();
        handleStageSelect(parseInt(button.getAttribute('data-stage'), 10));
      });
    });

    // ======================
    //   Give Up ボタン
    // ======================
    function handleGiveUp(e) {
      e.preventDefault();
      if (giveUpState === 'giveUp') {
        giveUpButton.textContent = 'Restart';
        giveUpButton.classList.add('restart');
        giveUpState = 'restart';
      } else {
        giveUpButton.textContent = 'Give Up';
        giveUpButton.classList.remove('restart');
        giveUpState = 'giveUp';
        startStage(currentStage);
      }
    }

    giveUpButton.addEventListener('touchend', handleGiveUp, { passive: false });
    giveUpButton.addEventListener('click', handleGiveUp);

    // ======================
    //   ステージ開始
    // ======================
    function startStage(stageNumber) {
      currentStage = stageNumber;
      attackBlocks = [];
      setupStage(stageNumber);
      drawAreas();

      if (gameInterval) clearInterval(gameInterval);
      virusGrowthCounter = 0;
      enemyActionCounter = 0;
      // 50msごとに更新 (20fps)
      gameInterval = setInterval(gameLoop, 50);

      // Give Up表示
      giveUpButton.style.display = 'block';
      giveUpButton.textContent = 'Give Up';
      giveUpButton.classList.remove('restart');
      giveUpState = 'giveUp';
    }

    // ======================
    //   ステージ設定
    // ======================
    function setupStage(stageNumber) {
      const index = stageNumber - 1;
      if (index >= 0 && index < stages.length) {
        const stageData = stages[index];
        areas = stageData.areas.map(a => ({ ...a }));
        connections = stageData.connections.map(c => [...c]);
      } else {
        // もしステージ11以降を作るならここでランダム生成等
        areas = [];
        connections = [];
      }
      selectedArea = null;
    }

    // ======================
    //   描画
    // ======================
    function drawAreas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ステージ番号：上中央に表示
      ctx.fillStyle = 'black';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText(`ステージ ${currentStage}`, canvas.width / 2, 10);

      // エリア間の線（20%短く）
      connections.forEach(conn => {
        const area1 = areas.find(a => a.id === conn[0]);
        const area2 = areas.find(a => a.id === conn[1]);
        if (!area1 || !area2) return;

        // 中心間の距離
        const dx = area2.x - area1.x;
        const dy = area2.y - area1.y;
        const distance = Math.sqrt(dx*dx + dy*dy);

        // 線の長さは (distance - 2*AREA_RADIUS)
        // →20%短くする → 80%にする  => newLineDist = (distance - 2*AREA_RADIUS)*0.8
        // → 端から (AREA_RADIUS + shortenHalf) だけ進んだ位置に始点を置く
        const lineDistance = distance - 2 * AREA_RADIUS;
        if (lineDistance <= 0) return; // エリアが重なる等の場合は描画しない

        const newLineDist = lineDistance * 0.8; // 80%化
        const shortenTotal = lineDistance - newLineDist; // 20%分
        const shortenHalf = shortenTotal / 2;            // 両端を10%ずつ

        const angle = Math.atan2(dy, dx);

        const x1 = area1.x + (AREA_RADIUS + shortenHalf) * Math.cos(angle);
        const y1 = area1.y + (AREA_RADIUS + shortenHalf) * Math.sin(angle);
        const x2 = area2.x - (AREA_RADIUS + shortenHalf) * Math.cos(angle);
        const y2 = area2.y - (AREA_RADIUS + shortenHalf) * Math.sin(angle);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      // 攻撃ブロック
      attackBlocks.forEach(block => {
        ctx.beginPath();
        ctx.arc(block.x, block.y, 12, 0, Math.PI * 2);
        ctx.fillStyle = (block.owner === 'player') ? 'red' : 'orange';
        ctx.fill();

        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(block.virusCount, block.x, block.y);
      });

      // エリア
      areas.forEach(area => {
        ctx.beginPath();
        ctx.arc(area.x, area.y, AREA_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle =
          (area.owner === 'player') ? 'red' :
          (area.owner === 'enemy') ? 'orange' : 'white';
        ctx.fill();

        // 選択エリア＆隣接エリアの強調
        let lineWidth = 1;
        let strokeStyle = 'black';
        if (selectedArea === area) {
          lineWidth = 5;
          strokeStyle = 'darkred';
        } else if (selectedArea && isNeighbor(selectedArea, area)) {
          lineWidth = 5;
          strokeStyle = 'darkblue';
        }

        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = strokeStyle;
        ctx.stroke();

        // ウイルス数と増殖率
        ctx.fillStyle = 'black';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(area.virusCount, area.x, area.y);
        ctx.fillText(`×${area.growthRate}`, area.x, area.y + 25);
      });
    }

    // ======================
    //   隣接判定
    // ======================
    function isNeighbor(fromArea, toArea) {
      return connections.some(conn =>
        (conn[0] === fromArea.id && conn[1] === toArea.id) ||
        (conn[1] === fromArea.id && conn[0] === toArea.id)
      );
    }

    // ======================
    //   座標変換
    // ======================
    function getCanvasCoordinates(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top)  * scaleY,
      };
    }

    // ======================
    //   タッチ/クリック処理
    // ======================
    function handleCanvasTap(x, y) {
      const clickedArea = areas.find(area => {
        const dx = area.x - x;
        const dy = area.y - y;
        return Math.sqrt(dx*dx + dy*dy) < AREA_RADIUS;
      });

      if (clickedArea) {
        if (!selectedArea) {
          // 自エリア選択
          if (clickedArea.owner === 'player' && clickedArea.virusCount > 0) {
            selectedArea = clickedArea;
            drawAreas();
          }
        } else {
          // 隣接ならウイルス移動
          if (isNeighbor(selectedArea, clickedArea)) {
            moveVirus(selectedArea.id, clickedArea.id);
            selectedArea = null;
            drawAreas();
          } else {
            selectedArea = null;
            drawAreas();
          }
        }
      } else {
        selectedArea = null;
        drawAreas();
      }
    }

    // スマホ用タッチ
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (e.changedTouches.length === 0) return;
      const touch = e.changedTouches[0];
      const { x, y } = getCanvasCoordinates(touch.clientX, touch.clientY);
      handleCanvasTap(x, y);
    }, { passive: false });

    // PC用クリック
    canvas.addEventListener('click', (e) => {
      const { x, y } = getCanvasCoordinates(e.clientX, e.clientY);
      handleCanvasTap(x, y);
    });

    // ======================
    //   ウイルス移動
    // ======================
    function moveVirus(fromId, toId) {
      const fromArea = areas.find(a => a.id === fromId);
      const toArea = areas.find(a => a.id === toId);
      if (!fromArea || !toArea) return;
      if (fromArea.owner !== 'player') return;

      // 同じルートに自ブロックが3つあると出せない
      const playerBlocksOnRoute = attackBlocks.filter(
        b => b.owner === 'player' && b.fromArea.id === fromArea.id && b.toArea.id === toArea.id
      );
      if (playerBlocksOnRoute.length >= 3) return;

      const movingVirus = fromArea.virusCount; // 全量移動
      if (movingVirus <= 0) return;
      fromArea.virusCount -= movingVirus;

      createAttackBlock(fromArea, toArea, movingVirus, 'player');
    }

    // ======================
    //   攻撃ブロック生成
    // ======================
    function createAttackBlock(fromArea, toArea, virusCount, owner) {
      const dx = toArea.x - fromArea.x;
      const dy = toArea.y - fromArea.y;
      const distance = Math.sqrt(dx*dx + dy*dy);
      const unitX = dx / distance;
      const unitY = dy / distance;

      // エリア外縁からスタート
      const startX = fromArea.x + AREA_RADIUS * unitX;
      const startY = fromArea.y + AREA_RADIUS * unitY;
      const endX = toArea.x - AREA_RADIUS * unitX;
      const endY = toArea.y - AREA_RADIUS * unitY;
      const totalDistance = Math.sqrt((endX - startX)**2 + (endY - startY)**2);

      attackBlocks.push({
        owner,
        virusCount,
        fromArea,
        toArea,
        x: startX,
        y: startY,
        dx: unitX,
        dy: unitY,
        totalDistance,
        distanceTraveled: 0,
        speed: ATTACK_BLOCK_SPEED,
      });
    }

    // ======================
    //   攻撃ブロック更新
    // ======================
    function updateAttackBlocks() {
      for (let i = 0; i < attackBlocks.length; i++) {
        const block = attackBlocks[i];
        block.distanceTraveled += block.speed;
        block.x += block.dx * block.speed;
        block.y += block.dy * block.speed;

        // 攻撃ブロック同士の衝突
        for (let j = i + 1; j < attackBlocks.length; j++) {
          const other = attackBlocks[j];
          const samePath =
            (block.fromArea.id === other.fromArea.id && block.toArea.id === other.toArea.id) ||
            (block.fromArea.id === other.toArea.id && block.toArea.id === other.fromArea.id);
          if (!samePath) continue;

          // 異なる所有者なら衝突判定
          if (block.owner !== other.owner) {
            const dx = block.x - other.x;
            const dy = block.y - other.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 24) {
              // 多いほうが生き残り、同数なら相殺
              if (block.virusCount > other.virusCount) {
                block.virusCount -= other.virusCount;
                attackBlocks.splice(j, 1);
                j--;
              } else if (block.virusCount < other.virusCount) {
                other.virusCount -= block.virusCount;
                attackBlocks.splice(i, 1);
                i--;
                break;
              } else {
                attackBlocks.splice(j, 1);
                attackBlocks.splice(i, 1);
                i--;
                break;
              }
            }
          }
        }

        // ターゲットエリア到達
        const distTarget = Math.sqrt((block.x - block.toArea.x)**2 + (block.y - block.toArea.y)**2);
        if (distTarget <= AREA_RADIUS || block.distanceTraveled >= block.totalDistance) {
          const toArea = block.toArea;
          const mv = block.virusCount;

          if (toArea.owner === block.owner) {
            toArea.virusCount += mv;
            if (toArea.virusCount > MAX_VIRUS_COUNT) {
              toArea.virusCount = MAX_VIRUS_COUNT;
            }
          } else if (toArea.owner === 'neutral') {
            if (mv > toArea.virusCount) {
              toArea.owner = block.owner;
              toArea.virusCount = mv - toArea.virusCount;
            } else if (mv === toArea.virusCount) {
              toArea.owner = 'neutral';
              toArea.virusCount = 0;
            } else {
              toArea.virusCount -= mv;
            }
          } else {
            if (mv > toArea.virusCount) {
              toArea.owner = block.owner;
              toArea.virusCount = mv - toArea.virusCount;
            } else if (mv === toArea.virusCount) {
              toArea.owner = 'neutral';
              toArea.virusCount = 0;
            } else {
              toArea.virusCount -= mv;
            }
          }
          if (toArea.virusCount > MAX_VIRUS_COUNT) {
            toArea.virusCount = MAX_VIRUS_COUNT;
          }

          // ブロック削除
          attackBlocks.splice(i, 1);
          i--;
        }
      }
    }

    // ======================
    //   敵の行動
    // ======================
    function enemyAction() {
      const enemyAreas = areas.filter(a => a.owner === 'enemy' && a.virusCount > 0);
      enemyAreas.forEach(area => {
        const neighbors = connections
          .filter(conn => conn.includes(area.id))
          .map(conn => conn[0] === area.id ? conn[1] : conn[0])
          .map(id => areas.find(a => a.id === id));

        if (!neighbors.length) return;

        let target;
        if (currentStage <= 5) {
          // ランダム攻撃
          target = neighbors[Math.floor(Math.random() * neighbors.length)];
        } else {
          // プレイヤーエリアを優先
          const playerAreas = neighbors.filter(a => a.owner === 'player');
          if (playerAreas.length > 0) {
            target = playerAreas.reduce((minA, a) =>
              (a.virusCount < minA.virusCount ? a : minA), playerAreas[0]);
          } else {
            target = neighbors[Math.floor(Math.random() * neighbors.length)];
          }
        }
        if (target && area.virusCount > 0) {
          const enemyBlocksOnRoute = attackBlocks.filter(
            b => b.owner === 'enemy' && b.fromArea.id === area.id && b.toArea.id === target.id
          );
          if (enemyBlocksOnRoute.length >= 3) return;

          const movingVirus = area.virusCount;
          if (movingVirus <= 0) return;
          area.virusCount -= movingVirus;

          createAttackBlock(area, target, movingVirus, 'enemy');
        }
      });
    }

    // ======================
    //   勝敗判定
    // ======================
    function checkGameStatus() {
      const playerOwned = areas.filter(a => a.owner === 'player').length;
      const total = areas.length;

      if (playerOwned === 0) {
        clearInterval(gameInterval);
        attackBlocks = [];
        gameOverOverlay.style.display = 'flex';
      } else if (playerOwned === total) {
        clearInterval(gameInterval);
        attackBlocks = [];
        levelCompleteOverlay.style.display = 'flex';
      }
    }

    // ======================
    //   ゲームループ
    // ======================
    function gameLoop() {
      virusGrowthCounter += 50;
      enemyActionCounter += 50;

      if (virusGrowthCounter >= 1000) {
        increaseVirusCounts();
        virusGrowthCounter = 0;
      }
      if (enemyActionCounter >= 1000 && currentStage !== 0) {
        enemyAction();
        enemyActionCounter = 0;
      }
      updateAttackBlocks();
      checkGameStatus();
      drawAreas();
    }

    // ======================
    //   ウイルス増殖
    // ======================
    function increaseVirusCounts() {
      areas.forEach(a => {
        if (a.owner !== 'neutral') {
          a.virusCount += a.growthRate;
          if (a.virusCount > MAX_VIRUS_COUNT) {
            a.virusCount = MAX_VIRUS_COUNT;
          }
        }
      });
    }

    // ======================
    //   画面イベント
    // ======================
    retryLevelButton.addEventListener('touchend', e => {
      e.preventDefault();
      levelCompleteOverlay.style.display = 'none';
      startStage(currentStage);
    }, { passive: false });
    retryLevelButton.addEventListener('click', e => {
      e.preventDefault();
      levelCompleteOverlay.style.display = 'none';
      startStage(currentStage);
    });

    nextLevelButton.addEventListener('touchend', e => {
      e.preventDefault();
      levelCompleteOverlay.style.display = 'none';
      startStage(currentStage + 1);
    }, { passive: false });
    nextLevelButton.addEventListener('click', e => {
      e.preventDefault();
      levelCompleteOverlay.style.display = 'none';
      startStage(currentStage + 1);
    });

    restartButton.addEventListener('touchend', e => {
      e.preventDefault();
      gameOverOverlay.style.display = 'none';
      initGame();
    }, { passive: false });
    restartButton.addEventListener('click', e => {
      e.preventDefault();
      gameOverOverlay.style.display = 'none';
      initGame();
    });

    retryButton.addEventListener('touchend', e => {
      e.preventDefault();
      gameOverOverlay.style.display = 'none';
      startStage(currentStage);
    }, { passive: false });
    retryButton.addEventListener('click', e => {
      e.preventDefault();
      gameOverOverlay.style.display = 'none';
      startStage(currentStage);
    });

    // 最初の状態を設定
    window.addEventListener('load', () => {
      initGame();
      drawAreas();
    });
  </script>
</body>
</html>
